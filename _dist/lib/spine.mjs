/*! ****************************************************************************
 * Spine v2.0.0
 *
 * A tiny MVC framework inspired from Backbone.js.
 * (you can download it from npm or github repositories)
 * Copyright (c) 2024 Mobilabs <contact@mobilabs.fr> (https://www.mobilabs.fr).
 * Released under the MIT license. You may obtain a copy of the License
 * at: http://www.opensource.org/licenses/mit-license.php).
 * Built from ES6Kadoo v2.2.1.
 * ************************************************************************** */
/*! Generated by Kadoo v1.3.0 */
// ESLint declarations
/* global define */
/* eslint no-shadow: ['error', { 'allow': ['root'] }] */
/* eslint strict: ["error", "function"] */
const $__ES6GLOB = {};
(function(root, factory) {
  'use strict';

  /* c8 ignore start */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([''], factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    /* eslint-disable-next-line no-param-reassign */
    module.exports = factory(root);
  } else {
    // Browser globals.
    /* eslint-disable-next-line no-param-reassign */
    root.Spine = factory(root);
  }
  /* c8 ignore stop */
}($__ES6GLOB, (root) => {
  'use strict';

  /* ***************************************************************************
   *
   * Tree is an object that links all the internal IIFE modules.
   *
   * ************************************************************************ */
  /* eslint-disable */
  let $__TREE = {"src":{"spine":{},"config":{},"components":{"model":{"main":{},"private":{"fetch":{},"util":{}}},"collection":{"main":{},"private":{"util1":{},"util2":{},"util3":{}}},"view":{"main":{}},"router":{"main":{},"util":{}},"history":{"main":{}},"radio":{"main":{}},"generic":{"main":{}}},"sync":{"main":{},"fetch":{}},"utils":{"util1":{}},"libs":{"_":{}}},"libin":{}};
  $__TREE.extend=function(o,m){var k=Object.keys(m);for(var i=0;i<k.length;i++){o[k[i]]=m[k[i]]}};
  $__TREE_RUN_EMBED_LIB();
  /* eslint-enable */

  /* index: 1, path: 'src/spine.js', import: [2, 3, 4, 5, 6, 7, 8, 9, 10] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Spine object.
     *
     * spine.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Private Static Methods:
     *  . _setTestMode                returns internal objects for testing purpose,
     *
     *
     * Public Static Methods:
     *  . noConflict                  returns a reference to this Spine object,
     *  . whoami                      returns the library name and version,
     *  . Model                       extends the Spine.Model object,
     *  . Collection                  extends the Spine.Collection object,
     *  . View                        extends the Spine.View object,
     *  . Router                      extends the Spine.Router object,
     *  . History                     returns the History object,
     *  . Radio                       returns the Radio object,
     *  . fetch                       fetches data on the server,
     *  . urify                       extends url with query parameters,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    // config must be imported the first as it is used by
    // model, collection, view ans router to initialize
    // the log library. Thus, $__TREE object must contain
    // the config object before the Javascript VM parses
    // those files.
    const { config } = $__TREE.src;
    const M = $__TREE.src.components.model.main;
    const C = $__TREE.src.components.collection.main;
    const V = $__TREE.src.components.view.main;
    const R = $__TREE.src.components.router.main;

    const History = $__TREE.src.components.history.main;
    const Radio = $__TREE.src.components.radio.main;
    const Sync = $__TREE.src.sync.main;
    const U = $__TREE.src.utils.util1;


    // -- Local Constants
    // Saves the previous value of the library variable, so that it can be
    // restored later on, if noConflict is used.
    const previousSpine = root.Spine;


    // -- Local Variables


    // -- Main -----------------------------------------------------------------

    const Spine = {

      // Useful to retrieve the library name and version when it is
      // embedded in another library as an object:
      _library: { name: 'Spine', version: '2.0.0' },


      // -- Private Static Methods ---------------------------------------------

      /**
       * Returns the internal objects for testing purpose.
       * (must not be deleted)
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {Object}      returns a list of internal objects,
       * @since 0.0.0
       */
      _setTestMode() {
        return [];
      },


      // -- Public Static Methods ----------------------------------------------

      /**
       * Returns a reference to this Spine object.
       * (must not be deleted)
       *
       * Nota:
       * Running Spine in no conflict mode, returns the Spine variable to
       * its previous owner.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the Spine object,
       * @since 0.0.0
       */
      noConflict() {
        /* eslint-disable-next-line no-param-reassign */
        root.Spine = previousSpine;
        return this;
      },

      /**
       * Returns the library name and version.
       * (must not be deleted)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the library name and version,
       * @since 0.0.0
       */
      whoami() {
        return this._library;
      },

      /**
       * Returns a reference to the Spine.Model object.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the optional parameters to extend the object,
       * @returns {Function}    returns the extended Spine.Model object,
       * @since 0.0.0
       */
      Model(methods) {
        return M.Model(methods);
      },

      /**
       * Returns a reference to the Spine.Collection object.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the optional parameters to extend the object,
       * @returns {Function}    returns the extended Spine.Collection object,
       * @since 0.0.0
       */
      Collection(methods) {
        return C.Collection(methods);
      },

      /**
       * Returns a reference to the Spine.View object.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the optional parameters to extend the object,
       * @returns {Function}    returns the extended Spine.View object,
       * @since 0.0.0
       */
      View(methods) {
        return V.View(methods);
      },

      /**
       * Returns a reference to the Spine.Router object.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the optional parameters to extend the object,
       * @returns {Function}    returns the extended Spine.Router object,
       * @since 0.0.0
       */
      Router(methods) {
        return R.Router(methods);
      },

      /**
       * Fetches data on the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      fetch(...args) {
        Sync.fetch(...args);
        return this;
      },

      /**
       * Extends url with query parameters,
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the server url,
       * @param {Object}        the query parameters,
       * @returns {String}      returns the URI or null,
       * @since 0.0.0
       */
      urify(...args) {
        return U.urify(...args);
      },

      // Returns the Spine.History and Spine.Radio objects.
      History,
      Radio,
    };


    // Attaches constants to Spine that provide name and version of the lib.
    Spine.NAME = 'Spine';
    Spine.VERSION = '2.0.0';


    // -- Export
    $__TREE.src.spine = Spine;

    /* eslint-enable no-underscore-dangle */
  }());

  /* index: 2, path: 'src/config.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * A set of configuration parameters.
     *
     * config.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none
     *
     *
     * Public Static Methods:
     *  . none,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Public ---------------------------------------------------------------

    const Config = {
      // Default Logger settings.
      logger: {
        level: 'warn',
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.config, Config);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 3, path: 'src/components/model/main.js', import: [11, 2, 12, 13, 10, 14, 15] */
  (function() {
    /** ************************************************************************
     *
     * Defines Spine.Model.
     *
     * pseudoclassical-auto.js is built upon a variation of the Pseudoclassical
     * Instantiation pattern. The object is instantiated by the new keyword
     * included in the constructor. The caller just needs to call the
     * constructor without the new keyword to get in return the object.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . Model                       returns the extended Spine.Model object,
     *
     *
     * Private Methods:
     *  . _intInitialize              checks if it needs to use $initialize or initialize,
     *  . _intListen                  checks if it needs to use $listen or listen,
     *  . _intParse                   checks if it needs to use $parse or parse,
     *  . _init                       makes private init. after creation,
     *  . _parse                      parses the received object.
     *
     *
     * Empty Public Methods:
     *  . $initialize                 makes extra initializations,
     *  . $listen                     listens for events,
     *  . $parse                      parses the downloaded object or bypass,
     *
     *
     * Public Methods:
     *  . $get                        returns the value of the req. model property,
     *  . $getAll                     returns an object with all the key/values,
     *  . $set                        sets or updates model properties,
     *  . $remove                     removes model property(ies),
     *  . $has                        checks if the model has the property,
     *  . $fetch                      retrieves a model from the server,
     *  . $save                       sends a model to the server,
     *  . $delete                     deletes a model from the server,
     *  . $urify                      extends url with query parameters,
     *
     *
     *
     * @namespace    Spine
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { KZlog } = $__TREE.libin;


    // -- Local Modules
    const { config } = $__TREE.src;
    const { _ } = $__TREE.src.libs;
    const Generic = $__TREE.src.components.generic.main;
    const U = $__TREE.src.utils.util1;
    const F = $__TREE.src.components.model.private.fetch;
    const U1 = $__TREE.src.components.model.private.util;


    // -- Local Constants
    const { level } = config.logger
        , log       = KZlog('Spine', level, false)
        ;


    // -- Local Variables
    let mmethods;


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the Spine.Model object.
     * (Pseudoclassical Instantation Pattern with auto instantatiation
     * - no need for new)
     *
     * @constructor (arg1)
     * @public
     * @param {String}          the argument to be saved as an object variable,
     * @returns {Object}        returns the Spine object,
     * @since 0.0.0
     */
    /* eslint-disable prefer-spread, prefer-rest-params */
    const Model = function(methods) {
      let args;
      const Child = function() {
        if (this instanceof Child) {
          Generic.Construct.apply(this, args);
          this._intInitialize.apply(this, args);
          this._intListen.apply(this);
          return this;
        }
        args = arguments;
        return new Child();
      };

      // We created our own assign method as Object.assign does not preserve
      // the getters and setters. So, do not use Object.assign here! And, do not
      // do this 'Child.prototype = _.assign(Generic.methods, methods)'! You will
      // copy the references instead of cloning the methods. And all the childs
      // will get the methods of the last created child.
      const p1 = _.assign({}, Generic.methods);
      const p2 = _.assign(p1, mmethods);
      Child.prototype = _.assign(p2, methods || {});
      Child.prototype.constructor = Child;
      return Child;
    };
    /* eslint-enable prefer-spread, prefer-rest-params */


    // -- Public Methods -------------------------------------------------------

    mmethods = {

      // -- Private Methods ----------------------------------------------------

      /**
       * Checks if it needs to use $initialize or the deprecated initialize method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intInitialize(...args) {
        if (!/^initialize\((.*)\)[^{]+\{\s*\}/m.test(this.initialize.toString())
        ) {
          log.warn('initialize method is deprecated, use $initialize instead!');
          this.initialize(...args);
          return;
        }
        this.$initialize(...args);
      },

      /**
       * Checks if it needs to use $listen or the deprecated listen method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intListen() {
        if (!/^listen\((.*)\)[^{]+\{\s*\}/m.test(this.listen.toString())
        ) {
          log.warn('listen method is deprecated, use $listen instead!');
          this.listen();
          return;
        }
        this.$listen();
      },

      /**
       * Checks if it needs to use $parse or the deprecated parse method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intParse(...args) {
        if (!/^parse\((.*)\)[^{]+\{\s*\}/m.test(this.parse.toString())
        ) {
          log.warn('parse method is deprecated, use $parse instead!');
          return this.parse(...args);
        }
        return this.$parse(...args);
      },

      /**
       * Makes initializations when the object is constructed.
       *
       * @method (...args)
       * @private
       * @param {}              -,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      _init(...args) {
        this.url = this.url || null;
        this.defaults = this.defaults || {};
        const [obj, options] = args;
        this._attributes = this._parse(obj, options);
        return this;
      },

      /**
       * Parses the received object.
       *
       * @method (arg1, arg2)
       * @private
       * @param {Object}        the received object,
       * @param {Object}        the options,
       * @returns {Object}      return the parsed object,
       * @since 0.0.0
       */
      /* eslint-disable no-restricted-syntax */
      _parse(data, options) {
        let obj = data || {};
        obj = options && options.parse ? this._intParse(obj) : obj;
        for (const item in this.defaults) {
          if (!obj[item]) {
            obj[item] = this.defaults[item];
          }
        }
        return obj;
      },
      /* eslint-enable no-restricted-syntax */


      // -- Empty Public Methods -----------------------------------------------

      /**
       * Makes the initializations.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      initialize() {},
      $initialize() {
        return this;
      },

      /**
       * Listens for events.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      listen() {},
      $listen() {
        return this;
      },

      /**
       * Parses the downloaded file.
       * (empty public method - could be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String}        the downloaded json file,
       * @returns {String}      returns the downloaded file,
       * @since 0.0.0
       */
      parse() {},
      $parse(attributes) {
        return attributes;
      },


      // -- Public Methods -----------------------------------------------------

      /**
       * Returns the value of the requested model property.
       * (public method - must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String}        the model property,
       * @returns {...}         returns the value of this property,
       * @since 0.0.0
       */
      $get(prop) {
        return typeof prop === 'string' ? this._attributes[prop] : null;
      },
      get(prop) {
        log.warn('get method is deprecated, use $get instead!');
        return this.$get(prop);
      },

      /**
       * Returns an object containing all the model properties.
       * (public method - must not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns the model properties,
       * @since 0.0.0
       */
      $getAll() {
        return { ...this._attributes };
      },
      getAll() {
        log.warn('getAll method is deprecated, use $getAll instead!');
        return this.$getAll();
      },

      /**
       * Sets or updates model properties.
       * (public method - must not be overwritten)
       *
       * Nota:
       * Fires a 'change' event if not silent ({ silent: true }).
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object/String} the properties or one property,
       * @returns {Object/.}    the options or the property value,
       * @since 0.0.0
       */
      $set(...args) {
        return U1.set(this, ...args);
      },
      set(...args) {
        log.warn('set method is deprecated, use $set instead!');
        return this.$set(...args);
      },

      /**
       * Removes one or a set of model property(ies).
       * (public method - must not be overwritten)
       *
       * Nota:
       * It removes a property or a set of properties from a model but not from
       * the server. It fires the 'remove:prop' event for each property removed
       * and a 'remove' afterwards. Firing could be disabled with the option
       * { silent: true }.
       * if you want to update the model on the server too, you need to call
       * the 'save' method.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object/String} the properties or one property,
       * @returns {Object}      returns the removed properties and their values,
       * @since 0.0.0
       */
      $remove(...args) {
        return U1.remove(this, ...args);
      },
      remove(...args) {
        log.warn('remove method is deprecated, use $remove instead!');
        return this.$remove(...args);
      },

      /**
       * Checks if the model has the passed-in property.
       * (public method - must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String}        the property,
       * @returns {Boolean}     returns true if the property exist otherwise false,
       * @since 0.0.0
       */
      $has(prop) {
        if (typeof prop === 'string' && prop in this._attributes) {
          return true;
        }
        return false;
      },
      has(prop) {
        log.warn('has method is deprecated, use $has instead!');
        return this.$has(prop);
      },

      /**
       * Retrieves a model from the server.
       * (public method - must not be overwritten)
       *
       * Nota:
       * Fires a 'load' event if not silent ({ silent: true }).
       *
       * @method ([arg1], [arg2])
       * @public
       * @param {Object}        the options,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $fetch(...args) {
        F.fetch(this, this.url, ...args);
        return this;
      },
      fetch(...args) {
        log.warn('fetch method is deprecated, use $fetch instead!');
        return this.$fetch(...args);
      },

      /**
       * Adds or updates a model on the server.
       * (public method - must not be overwritten)
       *
       * Nota:
       * Fires a 'save' event if not silent ({ silent: true }).
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Object}        the updated attributes,
       * @param {Object}        the options,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      this,
       * @since 0.0.0
       */
      $save(...args) {
        F.save(this, this.url, ...args);
        return this;
      },
      save(...args) {
        log.warn('save method is deprecated, use $save instead!');
        return this.$save(...args);
      },

      /**
       * Removes a model from the server.
       * (public method - must not be overwritten)
       *
       * Nota:
       * Fires a 'delete' event if not silent ({ silent: true }).
       *
       * @method ([arg1], [arg2])
       * @public
       * @param {Object}        the options,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      this,
       * @since 0.0.0
       */
      $delete(...args) {
        F.delete(this, this.url, ...args);
        return this;
      },
      delete(...args) {
        log.warn('delete method is deprecated, use $delete instead!');
        return this.$delete(...args);
      },

      /**
       * Extends url with query parameters,
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the server url,
       * @param {Object}        the query parameters,
       * @returns {String}      returns the URI or null,
       * @since 0.0.0
       */
      $urify(...args) {
        return U.urify(...args);
      },
      urify(...args) {
        log.warn('urify method is deprecated, use $urify instead!');
        return this.$urify(...args);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.model.main, { Model });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 4, path: 'src/components/collection/main.js', import: [11, 2, 12, 13, 3, 10, 16, 17, 18] */
  (function() {
    /** ************************************************************************
     *
     * Defines Spine.Collection.
     *
     * pseudoclassical-auto.js is built upon a variation of the Pseudoclassical
     * Instantiation pattern. The object is instantiated by the new keyword
     * included in the constructor. The caller just needs to call the
     * constructor without the new keyword to get in return the object.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . Collection                  returns the extended Spine.Collection object,
     *
     *
     * Private Methods:
     *  . _intInitialize              checks if it needs to use $initialize or initialize,
     *  . _intListen                  checks if it needs to use $listen or listen,
     *  . _init                       makes private init. after creation,
     *
     *
     * Empty Public Methods:
     *  . $initialize                 makes extra initializations,
     *  . $listen                     listens for events,
     *
     *
     * Public Methods:
     *  . $get                        gets a model from its cid or id,
     *  . $each                       returns the models one by one,
     *  . $next                       returns the next model from the given model,
     *  . $previous                   returns the previous model from the given model,
     *  . $length                     returns the number of models in the collection,
     *  . $set                        to be done .........,
     *  . $empty                      deletes the collection,
     *  . $add                        adds one or many objects to the collection,
     *  . $remove                     removes model(s) from the collection,
     *  . $fetch                      retrieves new models from the server,
     *  . $save                       adds or updates a set of model(s) on the server,
     *  . $delete                     deletes a set of models from server and collection,
     *  . $urify                      extends url with query parameters,
     *
     *
     *
     * @namespace    Spine
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { KZlog } = $__TREE.libin;


    // -- Local Modules
    const { config } = $__TREE.src;
    const { _ } = $__TREE.src.libs;
    const Generic = $__TREE.src.components.generic.main;
    const M = $__TREE.src.components.model.main;
    const U = $__TREE.src.utils.util1;
    const U1 = $__TREE.src.components.collection.private.util1;
    const U2 = $__TREE.src.components.collection.private.util2;
    const U3 = $__TREE.src.components.collection.private.util3;


    // -- Local Constants
    const { level } = config.logger
        , log       = KZlog('Spine', level, false)
        ;


    // -- Local Variables
    let cmethods;


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the Spine.Collection object.
     * (Pseudoclassical Instantation Pattern with auto instantatiation
     * - no need for new)
     *
     * @constructor (arg1)
     * @public
     * @param {String}          the argument to be saved as an object variable,
     * @returns {Object}        returns the Spine object,
     * @since 0.0.0
     */
    /* eslint-disable prefer-spread, prefer-rest-params */
    const Collection = function(methods) {
      let args;
      const Child = function() {
        if (this instanceof Child) {
          Generic.Construct.apply(this, args);
          this._intInitialize.apply(this, args);
          this._intListen.apply(this);
          return this;
        }
        args = arguments;
        return new Child();
      };

      // We created our own assign method as Object.assign does not preserve
      // the getters and setters. So, do not use Object.assign here! And, do not
      // do this 'Child.prototype = _.assign(Generic.methods, methods)'! You will
      // copy the references instead of cloning the methods. And all the childs
      // will get the methods of the last created child.
      const p1 = _.assign({}, Generic.methods);
      const p2 = _.assign(p1, cmethods);
      Child.prototype = _.assign(p2, methods || {});
      Child.prototype.constructor = Child;
      return Child;
    };
    /* eslint-enable prefer-spread, prefer-rest-params */


    // -- Public Methods -------------------------------------------------------

    cmethods = {

      // -- Private Methods ----------------------------------------------------

      /**
       * Checks if it needs to use $initialize or the deprecated initialize method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intInitialize(...args) {
        if (!/^initialize\((.*)\)[^{]+\{\s*\}/m.test(this.initialize.toString())
        ) {
          log.warn('initialize method is deprecated, use $initialize instead!');
          this.initialize(...args);
          return;
        }
        this.$initialize(...args);
      },

      /**
       * Checks if it needs to use $listen or the deprecated listen method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intListen() {
        if (!/^listen\((.*)\)[^{]+\{\s*\}/m.test(this.listen.toString())
        ) {
          log.warn('listen method is deprecated, use $listen instead!');
          this.listen();
          return;
        }
        this.$listen();
      },

      /**
       * Makes initializations when the object is constructed.
       *
       * @method ([arg0])
       * @private
       * @param {}              -,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      _init(...args) {
        this._ids = [];
        this._cids = [];
        this._models = [];
        this.url = this.url || null;
        this.model = this.model || M.Model();
        this.$add(args[0]);
        return this;
      },


      // -- Empty Public Methods -----------------------------------------------

      /**
       * Makes the initializations.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      initialize() {},
      $initialize() {
        return this;
      },

      /**
       * Listens for events.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      listen() {},
      $listen() {
        return this;
      },


      // -- Public Methods -----------------------------------------------------

      /**
       * Gets a model from a collection specified by its cid or id.
       * (public method - must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String/Number} the cid or id of the model,
       * @returns {Object}      returns the found model or null,
       * @since 0.0.0
       */
      $get(id) {
        return U2.get(this, id);
      },
      get(id) {
        log.warn('get method is deprecated, use $get instead!');
        return this.$get(id);
      },

      /**
       * Returns all the models from a collection one by one.
       * (public method - must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {Function}      the function to call at each iteration,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $each(callback) {
        for (let i = 0; i < this._models.length; i++) {
          callback(this._models[i], i);
        }
        return this;
      },
      each(callback) {
        log.warn('each method is deprecated, use $each instead!');
        return this.$each(callback);
      },

      /**
       * Returns the next model in a collection from the passed-in model.
       * (public method - must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String/Number} the cid or id of the model,
       * @returns {Object}      returns the found model or null,
       * @since 0.0.0
       */
      $next(id) {
        return U2.next(this, id);
      },
      next(id) {
        log.warn('next method is deprecated, use $next instead!');
        return this.$next(id);
      },

      /**
       * Returns the previous model in a collection from the passed-in model.
       * (public method - must not be overwritten)
       *
       * @method (arg1)
       * @public
       * @param {String/Number} the cid or id of the model,
       * @returns {Object}      returns the found model or null,
       * @since 0.0.0
       */
      $previous(id) {
        return U2.previous(this, id);
      },
      previous(id) {
        log.warn('previous method is deprecated, use $previous instead!');
        return this.$previous(id);
      },

      /**
       * Returns the collection length.
       * (public method - must not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Number}      returns the collection length,
       * @since 0.0.0
       */
      $length() {
        return this._models.length;
      },
      length() {
        log.warn('length method is deprecated, use $length instead!');
        return this.$length();
      },

      /**
       * Deletes the collection.
       * (public method - must not be overwritten)
       *
       * Nota:
       * It empties the collection but it doesn't delete the model from the
       * server. If you want to remove models from the collection and from
       * the server, you have to use the 'remove' method.
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $empty() {
        this._ids = [];
        this._cids = [];
        this._models = [];
        return this;
      },
      empty() {
        log.warn('empty method is deprecated, use $empty instead!');
        return this.$empty();
      },

      /**
       * Adds a model to the collection.
       * (public method - must not be overwritten)
       *
       * Nota:
       * adds a model to the collection except if a model with the same
       * id already exist otherwise updates this model in the collection.
       * Each time a model is added, the event 'add' is fired.
       * When all the models are added the event 'addcomplete' is fired.
       *
       * The add method doesn't update the server. It you want to add the new
       * model to the server, you need to call the 'fetch' model method on
       * 'add' event.
       *
       * However, the 'add' method is used by 'fetch' to update the collection.
       * As, fetch doesn't want to fire 'add' and 'addcomplete' events, it uses
       * 'add' method with { silent: true } to prevent 'add' method firing events
       * in this case.
       *
       * @method (arg1, [arg2])
       * @public
       * @param {Object/Array}  one or many objects to add,
       * @param {Object}        options to disable firing events,
       * @returns {Array}       returns the added models,
       * @since 0.0.0
       */
      $add(models, options) {
        return U1.add(this, models, options);
      },
      add(models, options) {
        log.warn('add method is deprecated, use $add instead!');
        return this.$add(models, options);
      },

      /**
       * Removes model(s) from the collection.
       * (public method - must not be overwritten)
       *
       * Nota:
       * It removes a model or a set of models from a collection but not from
       * the server. It fires the 'remove' event for each model removed and an
       * 'removecomplete' afterwards. Firing could be disabled with the option
       * { silent: true }.
       * if you want to remove the model from the server too, you need to call
       * the model's 'delete' method.
       *
       * @method (arg1, [arg2])
       * @public
       * @param {String/Object} the cid, id or model to remove or arrays of,
       * @param {Object}        options to disable firing events,
       * @returns {Array}       returns the removed models,
       * @since 0.0.0
       */
      $remove(arg, options) {
        return U1.remove(this, arg, options);
      },
      remove(arg, options) {
        log.warn('remove method is deprecated, use $remove instead!');
        return this.$remove(arg, options);
      },

      /**
       * Retrieves new models from the server.
       * (public method - must not be overwritten)
       *
       * Nota:
       * The retrieved new collection is appended to the current collection.
       * If you want a fresh new collection, you must empty the previous
       * one first.
       *
       * @method ([arg1], [arg2])
       * @public
       * @param {Object}        the query parameters,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $fetch(...args) {
        U1.fetch(this, ...args);
        return this;
      },
      fetch(...args) {
        log.warn('fetch method is deprecated, use $fetch instead!');
        return this.$fetch(...args);
      },

      /**
       * Adds or updates a set of model(s) on the server.
       * (public method - must not be overwritten)
       *
       * Nota:
       * Fires a 'save' event if not silent ({ silent: true }).
       *
       * @method (arg1, arg2, [arg3], [arg4])
       * @public
       * @param {String}        the where clause,
       * @param {Object}        the attributes to update,
       * @param {Object}        the options,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      this,
       * @since 0.0.0
       */
      $save(...args) {
        U3.save(this, this.url, ...args);
        return this;
      },
      save(...args) {
        log.warn('save method is deprecated, use $save instead!');
        return this.$save(...args);
      },

      /**
       * Deletes a set of models from the server.
       * (public method - must not be overwritten)
       *
       * Nota:
       * It removes a set of models from the server and the collection. It fires
       * the 'delete' event when it's done. Firing could be disabled with the option
       * { silent: true }.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Array}         the list of ids to remove,
       * @param {Object}        the optional parameters,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $delete(...args) {
        U2.delete(this, ...args);
        return this;
      },
      delete(...args) {
        log.warn('delete method is deprecated, use $delete instead!');
        return this.$delete(...args);
      },

      /**
       * Extends url with query parameters,
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the server url,
       * @param {Object}        the query parameters,
       * @returns {String}      returns the URI or null,
       * @since 0.0.0
       */
      $urify(...args) {
        return U.urify(...args);
      },
      urify(...args) {
        log.warn('urify method is deprecated, use $urify instead!');
        return this.$urify(...args);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.collection.main, { Collection });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 5, path: 'src/components/view/main.js', import: [11, 2, 12, 13] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Spine.View object.
     *
     * main.js is built upon a variation of the Pseudoclassical
     * Instantiation pattern. The object is instantiated by the new keyword
     * included in the constructor. The caller just needs to call the
     * constructor without the new keyword to get in return the object.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . View                        creates the Spine.View object,
     *
     *
     * Private Methods:
     *  . _intInitialize              checks if it needs to use $initialize or initialize,
     *  . _intListen                  checks if it needs to use $listen or listen,
     *  . _init                       makes init when the object is constructed,
     *
     *
     * Empty Public Methods:
     *  . $initialize                 makes the initializations,
     *  . $listen                     listens for events,
     *  . $render                     renders the View in the DOM,
     *
     *
     * Public Methods:
     *  . none,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { KZlog } = $__TREE.libin;


    // -- Local Modules
    const { config } = $__TREE.src;
    const { _ } = $__TREE.src.libs;
    const Generic = $__TREE.src.components.generic.main;


    // -- Local Constants
    const { level } = config.logger
        , log       = KZlog('Spine', level, false)
        ;


    // -- Local Variables
    let vmethods;


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the child component constructor.
     *
     * This function creates a child component that inherits from the Generic
     * component and extends the Generic component with its own methods.
     * Then, this function returns the child component constructor.
     *
     * @constructor (arg1)
     * @public
     * @param {}                -,
     * @returns {Object}        returns the View object,
     * @since 0.0.0
     */
    /* eslint-disable prefer-spread, prefer-rest-params */
    const View = function(methods) {
      let args;
      const Child = function() {
        if (this instanceof Child) {
          Generic.Construct.apply(this, args);
          this._intInitialize.apply(this, args);
          this._intListen.apply(this);
          return this;
        }
        args = arguments;
        return new Child();
      };

      // We created our own assign method as Object.assign does not preserve
      // the getters and setters. So, do not use Object.assign here! And, do not
      // do this 'Child.prototype = _.assign(Generic.methods, methods)'! You will
      // copy the references instead of cloning the methods. And all the childs
      // will get the methods of the last created child.
      const p1 = _.assign({}, Generic.methods);
      const p2 = _.assign(p1, vmethods);
      Child.prototype = _.assign(p2, methods || {});
      Child.prototype.constructor = Child;
      return Child;
    };
    /* eslint-enable prefer-spread, prefer-rest-params */


    vmethods = {

      // -- Private Methods ----------------------------------------------------

      /**
       * Checks if it needs to use $initialize or the deprecated initialize method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intInitialize(...args) {
        if (!/^initialize\((.*)\)[^{]+\{\s*\}/m.test(this.initialize.toString())
        ) {
          log.warn('initialize method is deprecated, use $initialize instead!');
          this.initialize(...args);
          return;
        }
        this.$initialize(...args);
      },

      /**
       * Checks if it needs to use $listen or the deprecated listen method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intListen() {
        if (!/^listen\((.*)\)[^{]+\{\s*\}/m.test(this.listen.toString())
        ) {
          log.warn('listen method is deprecated, use $listen instead!');
          this.listen();
          return;
        }
        this.$listen();
      },

      /**
       * Makes initializations when the object is constructed.
       *
       * @method (...args)
       * @private
       * @param {}            -,
       * @returns {Object}    return this,
       * @since 0.0.0
       */
      _init() {
        return this;
      },


      // -- Empty Public Methods -----------------------------------------------

      /**
       * Makes the initializations.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      initialize() {},
      $initialize() {
        return this;
      },

      /**
       * Listens for events.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      listen() {},
      $listen() {
        return this;
      },

      /**
       * Renders the View in the DOM.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      render() {},
      $render() {
        return this;
      },


      // -- Public Methods -----------------------------------------------------
      // none,
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.view.main, { View });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 6, path: 'src/components/router/main.js', import: [11, 2, 12, 13, 7, 19] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Spine.Router object.
     *
     * main.js is built upon a variation of the Pseudoclassical
     * Instantiation pattern. The object is instantiated by the new keyword
     * included in the constructor. The caller just needs to call the
     * constructor without the new keyword to get in return the object.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . Router                      creates and returns the Router object,
     *
     *
     * Private Methods:
     *  . _intInitialize              checks if it needs to use $initialize or initialize,
     *  . _intListen                  checks if it needs to use $listen or listen,
     *  . _init                       makes init when the object is constructed,
     *
     *
     * Empty Public Methods:
     *  . $initialize                 makes the initializations,
     *  . $listen                     listens for bus messages,
     *
     *
     * Public Methods:
     *  . $execute                    calls the matching route,
     *  . $navigate                   updates the url or triggers a route,
     *  . $getLastRoute               returns the latest route stored in the history,
     *  . $stop                       stops the router to listen for hash changes,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { KZlog } = $__TREE.libin;


    // -- Local Modules
    const { config } = $__TREE.src;
    const { _ } = $__TREE.src.libs;
    const Generic = $__TREE.src.components.generic.main;
    const History = $__TREE.src.components.history.main;
    const Util = $__TREE.src.components.router.util;


    // -- Local Constants
    const { level } = config.logger
        , log       = KZlog('Spine', level, false)
        ;


    // -- Local Variables
    let vmethods;


    // -- Public ---------------------------------------------------------------

    /**
     * Returns the child component constructor.
     *
     * This function creates a child component that inherits from the Generic
     * component and extends the Generic component with its own methods.
     * Then, this function returns the child component constructor.
     *
     * @constructor (arg1)
     * @public
     * @param {}                -,
     * @returns {Object}        returns the Spine.Router object,
     * @since 0.0.0
     */
    /* eslint-disable prefer-spread, prefer-rest-params */
    const Router = function(methods) {
      let args;
      const Child = function() {
        if (this instanceof Child) {
          Generic.Construct.apply(this, args);
          this._intInitialize.apply(this, args);
          this._intListen.apply(this);
          return this;
        }
        args = arguments;
        return new Child();
      };

      // We created our own assign method as Object.assign does not preserve
      // the getters and setters. So, do not use Object.assign here! And, do not
      // do this 'Child.prototype = _.assign(Generic.methods, methods)'! You will
      // copy the references instead of cloning the methods. And all the childs
      // will get the methods of the last created child.
      const p1 = _.assign({}, Generic.methods);
      const p2 = _.assign(p1, vmethods);
      Child.prototype = _.assign(p2, methods || {});
      Child.prototype.constructor = Child;
      return Child;
    };
    /* eslint-enable prefer-spread, prefer-rest-params */


    vmethods = {

      // -- Private Methods ----------------------------------------------------

      /**
       * Checks if it needs to use $initialize or the deprecated initialize method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intInitialize(...args) {
        if (!/^initialize\((.*)\)[^{]+\{\s*\}/m.test(this.initialize.toString())
        ) {
          log.warn('initialize method is deprecated, use $initialize instead!');
          this.initialize(...args);
          return;
        }
        this.$initialize(...args);
      },

      /**
       * Checks if it needs to use $listen or the deprecated listen method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {}            -,
       * @since 0.0.0
       */
      _intListen() {
        if (!/^listen\((.*)\)[^{]+\{\s*\}/m.test(this.listen.toString())
        ) {
          log.warn('listen method is deprecated, use $listen instead!');
          this.listen();
          return;
        }
        this.$listen();
      },

      /**
       * Makes initializations when the object is constructed.
       *
       * @method (...args)
       * @private
       * @param {}              -,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      _init() {
        this._trigger = true;
        this._replace = false;
        this.routes = this.routes || {};
        Util.startListeningHashChange(this);
        return this;
      },


      // -- Empty Public Methods -----------------------------------------------

      /**
       * Makes the initializations.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      initialize() {},
      $initialize() {
        return this;
      },

      /**
       * Listens for bus messages.
       * (empty public method - could be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      listen() {},
      $listen() {
        return this;
      },


      // -- Public Methods -----------------------------------------------------

      /**
       * Calls the matching route.
       * (public method - could be overwritten)
       *
       * Nota:
       * it is called internally by the router whenever a route matches with
       * the function to be executed as the first argument. You can add here
       * some preprocessing stuff before calling the matching route or stopping
       * it.
       *
       * @method (arg1)
       * @public
       * @param {Function}      the function to call,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $execute(callback, ...args) {
        if (callback) callback.apply(this, args);
        return this;
      },
      execute(callback, ...args) {
        log.warn('execute method is deprecated, use $execute instead!');
        return this.$execute(callback, ...args);
      },

      /**
       * Updates the URL or triggers a route.
       * (public method - must not be overwritten)
       *
       * Nota:
       * By default 'navigate' updates the url and the history. If trigger is set
       * to true, it calls the route. For instance, if you are at 'home' and you
       * want to set the url to 'home' and save it in this history, do:
       *  . navigate('home')
       * If you aren't at 'home' and you want to go, do:
       *  . navigate('home', { trigger: true }).
       *
       * If you don't want to update the history, set 'replace' to true.
       *
       * @method (arg1, [arg2])
       * @public
       * @param {String}        the route,
       * @param {Object}        trigger or not & update history or not,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $navigate(path, options) {
        this._trigger = options && options.trigger;
        this._replace = options && options.replace;
        /* eslint-disable-next-line no-restricted-globals */
        location.hash = `#${path}`;
        return this;
      },
      navigate(path, options) {
        log.warn('navigate method is deprecated, use $navigate instead!');
        return this.$navigate(path, options);
      },

      /**
       * Returns the latest route stored in the history.
       * (public method - mist not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {String}      returns the route stored in the history,
       * @since 0.0.0
       */
      $getLastRoute() {
        return History.get();
      },
      getLastRoute() {
        log.warn('getLastRoute method is deprecated, use $getLastRoute instead!');
        return this.$getLastRoute();
      },

      /**
       * Stops the router to listen for hash changes.
       * (public method - mist not be overwritten)
       *
       * @method ()
       * @public
       * @param {}              -,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $stop() {
        Util.stopListeningHashChange();
        return this;
      },
      stop() {
        log.warn('stop method is deprecated, use $stop instead!');
        return this.$stop();
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.router.main, { Router });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 7, path: 'src/components/history/main.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Spine.history object.
     *
     * main.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Static Methods:
     *  . start                       starts recording the route history,
     *  . stop                        stops recording the route history,
     *  . isHistoryRunning            returns the history state,
     *  . get                         returns the route in the history stack,
     *  . push                        pushes a route in the stack,
     *  . pop                         removes the latest entered route and returns it,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants
    const MAXSTACK = 25;


    // -- Local Variables


    // -- Public Static Methods ------------------------------------------------

    const History = {

      // history stack
      _history: null,

      /**
       * Starts recording the route history.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @throws {Object}       throws an error if the history is started twice,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      start() {
        if (!this._history) {
          this._history = [];
          return this;
        }
        throw new Error('Spine.history is already running!');
      },

      /**
       * Stops recording the route history.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      stop() {
        this._history = null;
        return this;
      },

      /**
       * Returns the history state.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {Boolean}     return the history state,
       * @since 0.0.0
       */
      isHistoryRunning() {
        if (this._history) {
          return true;
        }
        return false;
      },

      /**
       * Returns the route in the history stack.
       *
       * Nota:
       * If no value is specified, it returns the latest entered value.
       *
       * @method (arg1)
       * @private
       * @param {Number}        the stack index starting from the latest entered,
       * @throws {Object}       throws an error if the history isn't started,
       * @returns {String}      return the requested route,
       * @since 0.0.0
       */
      get(index) {
        if (this._history) {
          let i = -1;
          if (index && typeof index === 'number' && index < 0) {
            i = this._history.length + index >= 0
              ? index
              : -this._history.length;
          }
          return this._history[this._history.length + i];
        }
        throw new Error('Spine.history is NOT running!');
      },

      /**
       * Pushes a route in the stack.
       *
       * Nota:
       * In a normal usage you should not use this method. The object route
       * fills the stack.
       *
       * @method (arg1)
       * @private
       * @param {String}        the route to record in the history stack,
       * @throws {Object}       throws an error if the history is started twice,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      push(route) {
        if (this._history) {
          if (route && typeof route === 'string') {
            this._history.push(route);
            if (this._history.length > MAXSTACK) {
              this._history.shift();
            }
          }
          return this;
        }
        throw new Error('Spine.history is NOT running!');
      },

      /**
       * Removes the latest entered route and returns it.
       *
       * Nota:
       * In a normal usage you should not use this method.
       *
       * @method ()
       * @private
       * @param {}              -,
       * @returns {String}      returns the latest entered route,
       * @since 0.0.0
       */
      pop() {
        if (this._history) {
          return this._history.pop();
        }
        throw new Error('Spine.history is NOT running!');
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.history.main, History);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 8, path: 'src/components/radio/main.js', import: [20] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Spine.radio object.
     *
     * main.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Static Methods:
     *  . on                          listens for an event,
     *  . one                         listens for an event once,
     *  . off                         stops Listening the passed-in event,
     *  . fire                        fires an event,
     *  . trigger                     fires an event,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { Messenger } = $__TREE.libin;


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Public Static Methods ------------------------------------------------

    const Radio = {

      _mess: Messenger(),

      /**
       * Listens for an event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message event,
       * @param {Function}      the function to call when the event occurs,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      on(event, handler) {
        this._mess.subscribe(event, handler);
        return this;
      },

      /**
       * Listens for an event once.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message event,
       * @param {Function}      the function to call when the event occurs,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      one(event, handler) {
        this._mess.subscribeOnce(event, handler);
        return this;
      },

      /**
       * Stops Listening the passed-in event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message event,
       * @param {Function}      the handler to remove,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      off(event, handler) {
        this._mess.unsubscribe(event, handler);
        return this;
      },

      /**
       * Fires an event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message,
       * @param {Object}        the payload to send to the listeners,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      fire(event, payload) {
        this._mess.publish(event, payload);
        return this;
      },

      /**
       * Fires an event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message,
       * @param {Object}        the payload to send to the listeners,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      trigger(event, payload) {
        this.fire(event, payload);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.radio.main, Radio);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 9, path: 'src/sync/main.js', import: [21] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Spine.Sync function.
     *
     * main.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Public Static Methods:
     *  . fetch                       fetches data on the server,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint */


    // -- Vendor Modules


    // -- Local Modules
    const F = $__TREE.src.sync.fetch;


    // -- Local Constants


    // -- Local Variables


    // -- Public Static Methods ------------------------------------------------

    const Sync = {

      /**
       * Fetches data on the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {}            -,
       * @since 0.0.0
       */
      fetch(...args) {
        F.fetch(...args);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.sync.main, Sync);

    /* oOo */
  }());

  /* index: 10, path: 'src/utils/util1.js', import: [12] */
  (function() {
    /** ************************************************************************
     *
     * Implements a few shared utility primitives.
     *
     * util1.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _getUriArgs                 decodes the arguments,
     *  . _getQuery                   extracts url query,
     *  . _getPArams                  extracts url params,
     *  . _getUrl                     returns the url with queries,
     *  . _urify                      extends url with query parameters,
     *
     *
     * Public Static Methods:
     *  . getUrl                      returns the url with queries,
     *  . urify                       extends url with query parameters,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle, no-restricted-syntax */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.libs;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Decodes the arguments.
     *
     * @function (arg1, [arg2])
     * @private
     * @param {String}          the url,
     * @param {Object}          the query parameters,
     * @returns {Array}         returns an array with the url and the query,
     * @since 0.0.0
     */
    function _getUriArgs(...args) {
      const [arg1, arg2] = args;

      switch (args.length) {
        case 0:
          return [null, {}];

        case 1:
          if (_.isString(arg1)) {
            return [arg1, {}];
          }
          return [null, {}];

        default:
          if (_.isString(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2];
          }
          if (_.isString(arg1)) {
            return [arg1, {}];
          }
          return [null, {}];
      }
    }

    /**
     * Extracts url query.
     *
     * query must be an object containing the query to perform. For instance
     * '{ offset: 1, numbers: 3 }' is transformed to the string
     * '?offset=1&numbers=3'
     *
     * @function (arg1)
     * @private
     * @param {Object}          the query,
     * @returns {String}        returns the url query,
     * @since 0.0.0
     */
    function _getQuery(query) {
      if (!_.isLiteralObject(query)) return '';

      let s = '?';
      for (const item in query) {
        if ({}.hasOwnProperty.call(query, item) && query[item]) {
          s += `${item}=${query[item]}&`;
        }
      }
      s = encodeURI(s.slice(0, -1));
      return s;
    }

    /**
     * Extracts url params.
     *
     * params must be an object containing the url params. For instance
     * '{ _params: '/:offset/:numbers', offset: 1, numbers: 100 }' is
     * transformed to the string '/1/100'.
     *
     *
     * @function (arg1)
     * @private
     * @param {Object}          the query,
     * @returns {String}        returns the url query,
     * @since 0.0.0
     */
    function _getParams(params) {
      if (!_.isLiteralObject(params)) return '';

      let s = params._params;
      for (const item in params) {
        if (item !== '_params') {
          s = s.replace(`:${item}`, params[item]);
        }
      }
      return encodeURI(s);
    }

    /**
     * Returns the url with queries.
     *
     * @function (arg1, arg2)
     * @private
     * @param {String}          the server url,
     * @param {Object}          the fetch options,
     * @returns {String}        returns the extended url,
     * @since 0.0.0
     */
    function _getUrl(url, options) {
      if (options && (options.params || options.query)) {
        return options.params
          ? `${url}${_getParams(options.params)}`
          : `${url}${_getQuery(options.query)}`;
      }
      return url;
    }

    /**
     * Extends url with query parameters,
     *
     * @function (arg1, arg2)
     * @private
     * @param {String}        the server url,
     * @param {Object}        the query parameters,
     * @returns {String}      returns the URI or null,
     * @since 0.0.0
     */
    function _urify(...args) {
      const [url, options] = _getUriArgs(...args);
      if (!url) return null;
      return _getUrl(url, { query: options });
    }


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Returns the url with queries.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @returns {String}      returns the extended url,
       * @since 0.0.0
       */
      getUrl(url, options) {
        return _getUrl(url, options);
      },

      /**
       * Extends url with query parameters,
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the server url,
       * @param {Object}        the query parameters,
       * @returns {String}      returns the URI or null,
       * @since 0.0.0
       */
      urify(...args) {
        return _urify(...args);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.utils.util1, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle, no-restricted-syntax */
  }());

  /* index: 12, path: 'src/libs/_.js', import: [22] */
  (function() {
    /** ************************************************************************
     *
     * A simple interface with @mobilabs/overslash. As @mobilabs/overslash
     * contains a set of libraries, this interface prevents loaded multiple
     * versions of overslash.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Private Static Methods:
     *  . none,
     *
     *
     * Public Static Methods:
     *  . none,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* - */


    // -- Vendor Modules
    const _ = $__TREE.libin.Overslash;


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------
    // none,


    // -- Public Static Methods ------------------------------------------------
    // none,


    // -- Export
    $__TREE.extend($__TREE.src.libs._, _);

    /* oOo */
  }());

  /* index: 13, path: 'src/components/generic/main.js', import: [20, 11, 2] */
  (function() {
    /** ************************************************************************
     *
     * Defines the Generic Spine object. All the Spine objects inherits from
     * this object.
     *
     * main.js is built upon the Prototypal Instantiation pattern. It
     * returns an object by calling its constructor. It doesn't use the new
     * keyword.
     *
     * Private Functions:
     *  . none,
     *
     *
     * Constructor:
     *  . Construct                   creates the Generic Spine object,
     *
     *
     * Private Methods:
     *  . _ginit                      makes the generic init when the object is created,
     *
     *
     * Overwritable Private Methods:
     *  . none,
     *
     *
     * Empty Private Methods:
     *  . _init                       makes init when the object is constructed,
     *
     *
     * Empty Public Methods:
     *  . none
     *
     *
     * Public Methods:
     *  . $on                         listens for an event,
     *  . $one                        listens for an event once,
     *  . $off                        stops Listening the passed-in event,
     *  . $fire                       fires an event,
     *  . $trigger                    fires an event,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules
    const { Messenger } = $__TREE.libin;
    const { KZlog } = $__TREE.libin;


    // -- Local Modules
    const { config } = $__TREE.src;


    // -- Local Constants
    const { level } = config.logger
        , log       = KZlog('Spine', level, false)
        ;


    // -- Local Variables


    // -- Public ---------------------------------------------------------------

    /**
     * Defines the Generic Component constructor.
     * (Prototypal Instantiation Pattern)
     *
     * @constructor (...args)
     * @public
     * @param {}                -,
     * @returns {}              -,
     * @since 0.0.0
     */
    function Construct(...args) {
      this._ginit(...args);
      this._init(...args);
    }


    const methods = {

      // -- Private Methods ----------------------------------------------------

      /**
       * Makes the generic init when the object is constructed.
       * (private method - could not be overwritten)
       *
       * @method (...args)
       * @private
       * @param {}              -,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      _ginit() {
        this._mess = Messenger();
        return this;
      },


      // -- Empty Private Methods ----------------------------------------------

      /**
       * Makes initializations when the object is constructed.
       * (empty private method - could be overwritten)
       *
       * @method (...args)
       * @private
       * @param {}              -,
       * @returns {Object}      return this,
       * @since 0.0.0
       */
      _init() {
        return this;
      },


      // -- Overwritable Private Methods ---------------------------------------
      // none, (private method - could be overwritten)


      // -- Empty Public Methods -----------------------------------------------
      // none,


      // -- Public Methods -----------------------------------------------------

      /**
       * Listens for an event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message event,
       * @param {Function}      the function to call when the event occurs,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $on(event, handler) {
        this._mess.subscribe(event, handler);
        return this;
      },
      on(event, handler) {
        log.warn('on method is deprecated, use $on instead!');
        return this.$on(event, handler);
      },

      /**
       * Listens for an event once.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message event,
       * @param {Function}      the function to call when the event occurs,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $one(event, handler) {
        this._mess.subscribeOnce(event, handler);
        return this;
      },
      one(event, handler) {
        log.warn('one method is deprecated, use $one instead!');
        return this.$one(event, handler);
      },

      /**
       * Stops Listening the passed-in event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message event,
       * @param {Function}      the handler to remove,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      $off(event, handler) {
        this._mess.unsubscribe(event, handler);
        return this;
      },
      off(event, handler) {
        log.warn('off method is deprecated, use $off instead!');
        return this.$off(event, handler);
      },

      /**
       * Fires an event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message,
       * @param {Object}        the payload to send to the listeners,
       * @returns {Object}      returns this or null,
       * @since 0.0.0
       */
      $fire(event, payload) {
        this._mess.publish(event, payload);
        return this;
      },
      fire(event, payload) {
        log.warn('fire method is deprecated, use $fire instead!');
        return this.$fire(event, payload);
      },

      /**
       * Fires an event.
       *
       * @method (arg1, arg2)
       * @public
       * @param {String}        the message,
       * @param {Object}        the payload to send to the listeners,
       * @returns {Object}      returns this or null,
       * @since 0.0.0
       */
      $trigger(event, payload) {
        this.$fire(event, payload);
        return this;
      },
      trigger(event, payload) {
        log.warn('trigger method is deprecated, use $trigger instead!');
        return this.$trigger(event, payload);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.generic.main, { Construct, methods });

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 14, path: 'src/components/model/private/fetch.js', import: [12, 9, 10] */
  (function() {
    /** ************************************************************************
     *
     * Implements the fetch method.
     *
     * fetch.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _getArgs4FetchAndDelete     decodes the fetch and delete arguments,
     *  . _getArgs4Save               decodes the save arguments,
     *  . _fetch                      retrieves one object from the server,
     *  . _save                       sends one object to the server,
     *  . _delete                     removes a model from the server,
     *
     *
     * Public Static Methods:
     *  . fetch                       retrieves one object from the server,
     *  . save                        sends one object to the server,
     *  . delete                      removes a model from the server,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.libs;
    const F = $__TREE.src.sync.main;
    const U = $__TREE.src.utils.util1;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Decodes the delete arguments.
     *
     * @function ([arg1], [arg2])
     * @private
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion
     * @returns {Array}         returns an object with options, callback,
     * @since 0.0.0
     */
    function _getArgs4FetchAndDelete(...args) {
      const [arg1, arg2] = args;
      switch (args.length) {
        case 0:
          return [{}, null];

        case 1:
          if (_.isLiteralObject(arg1)) {
            return [arg1, null];
          }
          if (_.isFunction(arg1)) {
            return [{}, arg1];
          }
          return [{}, null];

        default:
          if (_.isLiteralObject(arg1) && _.isFunction(arg2)) {
            return [arg1, arg2];
          }
          if (_.isLiteralObject(arg1)) {
            return [arg1, null];
          }
          if (_.isFunction(arg1)) {
            return [{}, arg1];
          }
          return [{}, null];
      }
    }

    /**
     * Decodes the save arguments.
     *
     * @function ([arg1], [arg2], [arg3])
     * @private
     * @param {Object}          the modified model properties,
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion
     * @returns {Array}         returns an object with properties, options, callback,
     * @since 0.0.0
     */
    function _getArgs4Save(...args) {
      const [arg1, arg2, arg3] = args;
      switch (args.length) {
        case 0:
          return [null, null, null];

        case 1:
          if (_.isLiteralObject(arg1)) {
            return [arg1, {}, null];
          }
          return [null, null, null];

        case 2:
          if (_.isLiteralObject(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2, null];
          }
          if (_.isLiteralObject(arg1) && _.isFunction(arg2)) {
            return [arg1, {}, arg2];
          }
          if (_.isLiteralObject(arg1)) {
            return [arg1, {}, null];
          }
          return [null, null, null];

        default:
          if (_.isLiteralObject(arg1) && _.isLiteralObject(arg2) && _.isFunction(arg3)) {
            return [arg1, arg2, arg3];
          }
          if (_.isLiteralObject(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2, null];
          }
          if (_.isLiteralObject(arg1) && _.isFunction(arg2)) {
            return [arg1, {}, arg2];
          }
          if (_.isLiteralObject(arg1)) {
            return [arg1, {}, null];
          }
          return [null, null, null];
      }
    }

    /**
     * Retrieves one object from the server.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Object}          the model object,
     * @param {String}          the server url,
     * @param {Object}          the fetch options,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _fetch(model, url, ...args) {
      const [opts, callback] = _getArgs4FetchAndDelete(...args);

      const options = {
        method: 'GET',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      };

      let nurl;
      if (opts.params || opts.query) {
        nurl = U.getUrl(url, opts);
      } else {
        nurl = model._attributes.id
          ? `${url}/${model._attributes.id}`
          : `${url}/1`;
      }

      const type = opts.type === 'text' ? 'text' : 'json';
      F.fetch(nurl, options, type, (err, data) => {
        if (err) {
          if (callback) callback(err);
          return;
        }
        model._attributes = model._parse(data, opts);
        if (!opts.silent) model.$fire('load', model._attributes);
        if (callback) {
          callback(null, model._attributes);
        }
      });
    }
    /* eslint-enable no-param-reassign */

    /**
     * Sends one object to the server.
     *
     * @function (arg1, arg2, arg3, [arg4], [arg5])
     * @private
     * @param {Object}          the model object,
     * @param {String}          the server url,
     * @param {Object}          the updated attributes,
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _save(model, url, ...args) {
      const [changed, opts, callback] = _getArgs4Save(...args);
      if (!changed) return;

      const options = {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(changed),
      };

      const type = opts.type === 'text' ? 'text' : 'json';
      F.fetch(url, options, type, (err, res) => {
        if (err) {
          if (callback) callback(err);
        } else {
          if (!opts.silent) model.$fire('save', res);
          if (callback) callback(err, res);
        }
      });
    }

    /**
     * Removes a model from the server.
     *
     * @function (arg1, arg2, [arg3])
     * @public
     * @param {Object}          the model object,
     * @param {String}          the server url,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _delete(model, url, ...args) {
      const [opts, callback] = _getArgs4FetchAndDelete(...args)
          , id                  = model.$get('id')
          ;

      if (!id) {
        if (callback) callback(null, 'This model has no id. Thus, it does not exist on the server!');
        return;
      }

      if (!url) {
        if (callback) callback(null, 'This model has no url!');
        return;
      }

      const options = {
        method: 'DELETE',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      };

      const type = opts.type === 'text' ? 'text' : 'json';
      F.fetch(`${url}/${id}`, options, type, (err, res) => {
        if (err) {
          if (callback) callback(err);
        } else {
          if (!opts.silent) model.$fire('delete', res);
          if (callback) callback(err, res);
        }
      });
    }


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Retrieves one object from the server.
       *
       * @method (arg1, arg2, [arg3], [arg4)
       * @public
       * @param {Object}          the model object,
       * @param {String}          the server url,
       * @param {Object}          the fetch options,
       * @param {Function}        the function to call at the completion,
       * @returns {Object}        returns this,
       * @since 0.0.0
       */
      fetch(model, url, ...args) {
        _fetch(model, url, ...args);
        return this;
      },

      /**
       * Sends one object to the server.
       *
       * @method (arg1, arg2, arg3, [arg4], [arg5])
       * @public
       * @param {Object}        the model object,
       * @param {String}        the server url,
       * @param {Object}        the updated attributes,
       * @param {Object}        the options,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      save(model, url, ...args) {
        _save(model, url, ...args);
        return this;
      },

      /**
       * Removes a model from the server.
       *
       * @method (arg1, arg2, [arg3], [arg4])
       * @public
       * @param {Object}          the model object,
       * @param {String}          the server url,
       * @param {Object}          the options,
       * @param {Function}        the function to call at the completion,
       * @returns {Object}        returns this,
       * @since 0.0.0
       */
      delete(model, url, ...args) {
        _delete(model, url, ...args);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.model.private.fetch, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 15, path: 'src/components/model/private/util.js', import: [12] */
  (function() {
    /** ************************************************************************
     *
     * Implements a few utility primitives.
     *
     * util.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _getSetArgs                 decodes the arguments,
     *  . _getRmArgs                  decodes the arguments,
     *  . _remove                     removes the passed-in properties from a model,
     *  . _set                        updates the model,
     *
     *
     * Public Static Methods:
     *  . set                         updates the model,
     *  . remove                      removes the passed-in properties from a model,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.libs;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Decodes the arguments.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object/String}   the properties or one propery,
     * @param {Object/...}      the options or the property value,
     * @returns {Array}         returns an object with properties and options,
     * @since 0.0.0
     */
    function _getSetArgs(...args) {
      const [arg1, arg2, arg3] = args
          , obj = {}
          ;

      switch (args.length) {
        case 0:
          return [{}, {}];

        case 1:
          // must be: set({ a: 1 })
          if (_.isLiteralObject(arg1)) {
            return [arg1, {}];
          }
          return [{}, {}];

        case 2:
          // must be: set({ a: 1}, options)
          if (_.isLiteralObject(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2];
          }
          // or must be: set('a', 1)
          if (_.isString(arg1)) {
            obj[arg1] = arg2;
            return [obj, {}];
          }
          return [{}, {}];

        default:
          // must be: set('a', 1, options)
          if (_.isString(arg1) && _.isLiteralObject(arg3)) {
            obj[arg1] = arg2;
            return [obj, arg3];
          }
          // or must be: set('a', 1, ignored furbish)
          if (_.isString(arg1)) {
            obj[arg1] = arg2;
            return [obj, {}];
          }
          return [{}, {}];
      }
    }

    /**
     * Decodes the arguments.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Object/String}   the properties or one propery,
     * @param {Object/...}      the options or the property value,
     * @returns {Array}         returns an object with properties and options,
     * @since 0.0.0
     */
    function _getRmArgs(...args) {
      const [arg1, arg2] = args;

      switch (args.length) {
        case 0:
          return [[], {}];

        case 1:
          if (_.isString(arg1)) {
            return [[arg1], {}];
          }
          if (_.isArray(arg1)) {
            return [arg1, {}];
          }
          if (_.isLiteralObject(arg1)) {
            return [[], arg1];
          }
          return [[], {}];

        default:
          if (_.isString(arg1) && _.isLiteralObject(arg2)) {
            return [[arg1], arg2];
          }
          if (_.isArray(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2];
          }
          if (_.isString(arg1)) {
            return [[arg1], {}];
          }
          if (_.isArray(arg1)) {
            return [arg1, {}];
          }
          if (_.isLiteralObject(arg1)) {
            return [[], arg1];
          }
          if (_.isLiteralObject(arg2)) {
            return [[], arg2];
          }
          return [[], {}];
      }
    }

    /**
     * Removes the passed-in properties from the model.
     *
     * @function (arg1, [args])
     * @private
     * @param {Object}         the model object,
     * @param {Array}          the extra arguments,
     * @returns {Object}       returns the removed properties and their values,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign */
    function _remove(model, ...args) {
      const [obj, options] = _getRmArgs(...args)
          , mattr          = Object.keys(model._attributes)
          , out            = {}
          ;

      let o;
      obj.forEach((item) => {
        if (mattr.indexOf(item) > -1) {
          o = {};
          o[item] = model._attributes[item];
          out[item] = o[item];
          delete model._attributes[item];
          if (!options.silent) model.$fire('remove:prop', o);
        }
      });
      if (!options.silent) model.$fire('remove', out);
      return out;
    }
    /* eslint-enable no-param-reassign */

    /**
     * Updates the model with the passed-in properties.
     *
     * @function (arg1, [args])
     * @private
     * @param {Object}         the model object,
     * @param {Array}          the extra arguments,
     * @returns {Object}       returns the updated model,
     * @since 0.0.0
     */
    /* eslint-disable no-param-reassign, no-unused-vars,
      no-restricted-syntax */
    function _set(model, ...args) {
      const [obj, options] = _getSetArgs(...args);
      const out = {};

      let match;
      for (const item in obj) {
        if ({}.hasOwnProperty.call(obj, item)) {
          if (model._attributes[item] !== obj[item]) {
            model._attributes[item] = obj[item];
            out[item] = obj[item];
            if (!options.silent) model.$fire(`change:${item}`, obj[item]);
            match = true;
          }
        }
      }
      if (model._attributes.id) out.id = model._attributes.id;
      if (!options.silent && match) model.$fire('change', out);
      return model._attributes;
    }
    /* eslint-enable no-param-reassign, no-unused-vars,
      no-restricted-syntax */


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Updates the model with the passed-in properties.
       *
       * @method (arg1, [args])
       * @public
       * @param {Object}         the model object,
       * @param {Array}          the extra arguments,
       * @returns {Object}       returns the updated model,
       * @since 0.0.0
       */
      set(model, ...args) {
        return _set(model, ...args);
      },

      /**
       * Removes the passed-in properties from the model.
       *
       * @method (arg1, [args])
       * @public
       * @param {Object}         the model object,
       * @param {Array}          the extra arguments,
       * @returns {Object}       returns the removed properties and their values,
       * @since 0.0.0
       */
      remove(model, ...args) {
        return _remove(model, ...args);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.model.private.util, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 16, path: 'src/components/collection/private/util1.js', import: [12, 9, 10] */
  (function() {
    /** ************************************************************************
     *
     * Implements a few utility primitives.
     *
     * util.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _getArgs                    decodes the fetch arguments,
     *  . _add                        adds a model to the collection,
     *  . _rm                         removes one model from the collection,
     *  . _remove                     removes model(s) from the collection,
     *  . _fetch                      retrieves new models from the server,
     *
     *
     * Public Static Methods:
     *  . add                         adds model(s) to the collection,
     *  . remove                      removes model(s) from the collection,
     *  . fetch                       retrieves new models from the server,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.libs;
    const F = $__TREE.src.sync.main;
    const U = $__TREE.src.utils.util1;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Decodes the fetch arguments.
     *
     * @function ([arg1], [arg2])
     * @private
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion
     * @returns {Array}         returns an array with options, callback,
     * @since 0.0.0
     */
    function _getArgs(...args) {
      const [arg1, arg2] = args;

      switch (args.length) {
        case 0:
          return [{}, null];

        case 1:
          if (_.isLiteralObject(arg1)) {
            return [arg1, null];
          }
          if (_.isFunction(arg1)) {
            return [{}, arg1];
          }
          return [{}, null];

        default:
          if (_.isLiteralObject(arg1) && _.isFunction(arg2)) {
            return [arg1, arg2];
          }
          if (_.isLiteralObject(arg1)) {
            return [arg1, null];
          }
          if (_.isFunction(arg1)) {
            return [{}, arg1];
          }
          return [{}, null];
      }
    }

    /**
     * Adds a model to the collection.
     *
     * Nota:
     * adds a model to the collection except if a model with the same
     * id already exist. Each time a model is added, the event 'add' is fired.
     * When all the models are added the event 'addcomplete' is fired.
     *
     * However, the 'add' method is used by 'fetch' to update the collection.
     * As, fetch doesn't want to fire 'add' and 'addcomplete' events, it uses
     * 'add' method with { silent: true } to prevent 'add' method firing events
     * in this case.
     *
     * @function (arg1, arg2, [arg3])
     * @private
     * @param {Object}          the collection object,
     * @param {Object/Array}    an object or an array of objects,
     * @param {Object}          options to disable firing events,
     * @returns {Array}         returns the added objects,
     * @since 0.0.0
     */
    function _add(col, /* models */items, options) {
      const ids   = col._ids
          , cids  = col._cids
          , Model = col.model
          , out   = []
          ;

      let childs;
      if (_.isLiteralObject(items)) {
        childs = [items];
      } else if (_.isArray(items)) {
        childs = items;
      } else {
        childs = [];
      }

      let model
        , clomodel
        , id
        , mo
        , cm
        , attrs
        ;

      for (let i = 0; i < childs.length; i++) {
        if (_.isLiteralObject(childs[i])) {
          model = Model(childs[i], { parse: options && options.parse });
          id = model.$get('id');
          if (!ids.includes(id)) {
            if (id) {
              ids.push(id);
            }
            model.cid = `c${cids.length + 1}`;
            cids.push(model.cid);
            col._models.push(model);
            clomodel = _.clone(model);
            out.push(clomodel);
            if (!options || !options.silent) {
              col.$fire('add', clomodel);
            }
          } else {
            attrs = Object.keys(model.$getAll());
            mo = col.$get(model.$get('id'));
            for (let j = 0; j < attrs.length; j++) {
              mo._attributes[attrs[j]] = model._attributes[attrs[j]];
            }
            cm = _.clone(mo);
            out.push(cm);
            if (!options || !options.silent) col.$fire('add', cm);
          }
        }
      }

      if (!options || !options.silent) col.$fire('addcomplete', out);
      return out;
    }

    /**
     * Removes one model from the collection.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @private
     * @param {Array}           the collection of models,
     * @param {String/Number}   the cid/id of the model to remove,
     * @param {Array}           the array of cids,
     * @param {Array}           the array of ids,
     * @returns {Object}        returns the removed model,
     * @since 0.0.0
     */
    function _rm(models, id, cids, ids) {
      if (cids.indexOf(id) === -1 && ids.indexOf(id) === -1) return null;

      for (let i = 0; i < models.length; i++) {
        if (models[i].cid === id || models[i].$get('id') === id) {
          let index = cids.indexOf(models[i].cid);
          if (index > -1) cids.splice(index, 1);
          index = ids.indexOf(id);
          if (index > -1) ids.splice(index, 1);
          return models.splice(i, 1)[0];
        }
      }
      return null;
    }

    /**
     * Removes model(s) from the collection.
     *
     * Nota:
     * It removes a model or a set of models from a collection but not from
     * the server. It fires the 'remove' event for each model removed and an
     * 'removecomplete' afterwards. Firing could be disabled with the option
     * { silent: true }.
     * if you want to remove the model from the server too, you need to call
     * the model's 'delete' method.
     *
     * @function (arg1, arg2, [arg3])
     * @private
     * @param {Object}          the collection object,
     * @param {...}             an cid/id/model or an array of cid/id/model,
     * @param {Object}          options to disable firing events,
     * @returns {Array}         returns the removed models,
     * @since 0.0.0
     */
    function _remove(col, models, options) {
      let nmodels;
      if (_.isLiteralObject(models) || _.isString(models) || _.isNumber(models)) {
        nmodels = [models];
      } else if (_.isArray(models)) {
        nmodels = models;
      } else {
        nmodels = [];
      }

      const out = [];
      for (let i = 0; i < nmodels.length; i++) {
        let m;
        if (_.isLiteralObject(nmodels[i])) {
          m = _rm(col._models, nmodels[i].cid, col._cids, col._ids);
        } else if (_.isString(nmodels[i]) || _.isNumber(nmodels[i])) {
          m = _rm(col._models, nmodels[i], col._cids, col._ids);
        }
        if (m) {
          out.push(m);
          if (!options || !options.silent) col.$fire('remove', m);
        }
      }
      if (!options || !options.silent) col.$fire('removecomplete', out);
      return out;
    }

    /**
     * Retrieves new models from the server.
     *
     * Nota:
     * The retrieved new collection is appended to the current collection.
     * If you want a fresh new collection, you must empty the previous
     * one first.
     *
     * @function (arg1, [arg2], [arg3])
     * @private
     * @param {Object}          the collection object,
     * @param {Object}          the collection object,
     * @param {Object}          the query parameters,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _fetch(col, ...args) {
      const [options, callback] = _getArgs(...args)
          , nurl                = U.getUrl(col.url, options)
          ;

      const opts = {
        method: 'GET',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      };

      const type = options.type === 'text' ? 'text' : 'json';
      F.fetch(nurl, opts, type, (err, data) => {
        if (err) {
          if (callback) callback(err);
          return;
        }
        const out = col.$add(data, { silent: true, parse: options.parse });
        if (!options.silent) col.$fire('load', out);
        if (callback) {
          callback(null, out);
        }
      });
    }


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Adds a model to the collection.
       *
       * @method (arg1, arg2, [arg3])
       * @public
       * @param {Object}          the collection object,
       * @param {Object/Array}    an object or an array of objects,
       * @param {Object}          options to disable firing events,
       * @returns {Array}         returns the added objects,
       * @since 0.0.0
       */
      add(col, models, options) {
        return _add(col, models, options);
      },

      /**
       * Removes model(s) from the collection.
       *
       * @method (arg1, arg2, [arg3])
       * @public
       * @param {Object}          the collection object,
       * @param {...}             an cid/id/model or an array of cid/id/model,
       * @param {Object}          options to disable firing events,
       * @returns {Array}         returns the removed models,
       * @since 0.0.0
       */
      remove(col, models, options) {
        return _remove(col, models, options);
      },

      /**
       * Retrieves new models from the server.
       *
       * @method (arg1, [arg2], [arg3])
       * @public
       * @param {Object}        the collection object,
       * @param {Object}        the query parameters,
       * @param {Function}      the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      fetch(col, ...args) {
        _fetch(col, ...args);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.collection.private.util1, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 17, path: 'src/components/collection/private/util2.js', import: [12, 9] */
  (function() {
    /** ************************************************************************
     *
     * Implements a few utility primitives.
     *
     * util.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _nextOrprevious             returns the next/previous model in a collection,
     *  . _delArgs                    decodes the deleted arguments,
     *  . _delete                     deletes the requested models,
     *  . _get                        returns a model specified by a cid or an id,
     *
     *
     * Public Static Methods:
     *  . get                         returns a model specified by a cid or an id,
     *  . delete                      deletes the requested models,
     *  . next                        returns the next model in a collection,
     *  . previous                    returns the previous model in a collection,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.libs;
    const F = $__TREE.src.sync.main;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Returns the next or previous model in a collection from the passed-in model.
     *
     * @method (arg1, arg2, arg3)
     * @public
     * @param {Object}        the collection,
     * @param {String/Number} the cid or id of the model,
     * @param {Boolean}       true the next model, false the previous,
     * @returns {Object}      returns the found model or null,
     * @since 0.0.0
     */
    function _nextOrprevious(collection, id, next) {
      // let n = parseInt(id, 10);
      // n = !Number.isNaN(n) ? n : null;

      for (let i = 0; i < collection._models.length; i++) {
        if (collection._models[i].cid === id || collection._models[i]._attributes.id === id) {
          if (next) {
            return i + 1 >= collection._models.length
              ? collection._models[0]
              : collection._models[i + 1];
          }
          return i - 1 < 0
            ? collection._models[collection._models.length - 1]
            : collection._models[i - 1];
        }
      }
      return null;
    }

    /**
     * Decodes the deleted arguments.
     *
     * @function (arg1, [arg2], [arg3])
     * @private
     * @param {Array}           the list of ids,
     * @param {Object}          the optionale parameters,
     * @param {Function}        the function to call at the completion
     * @returns {Array}         returns an array with list, options, callback,
     * @since 0.0.0
     */
    function _delArgs(...args) {
      const [arg1, arg2, arg3] = args;

      switch (args.length) {
        case 0:
          return [[], {}, null];

        case 1:
          if (_.isArray(arg1)) {
            return [arg1, {}, null];
          }
          if (_.isFunction(arg1)) {
            return [[], {}, arg1];
          }
          return [[], {}, null];

        case 2:
          if (_.isArray(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2, null];
          }
          if (_.isArray(arg1) && _.isFunction(arg2)) {
            return [arg1, {}, arg2];
          }
          if (_.isArray(arg1)) {
            return [arg1, {}, null];
          }
          return [[], {}, null];

        default:
          if (_.isArray(arg1) && _.isLiteralObject(arg2) && _.isFunction(arg3)) {
            return [arg1, arg2, arg3];
          }
          if (_.isArray(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2, null];
          }
          if (_.isArray(arg1) && _.isFunction(arg2)) {
            return [arg1, {}, arg2];
          }
          if (_.isArray(arg1) && _.isFunction(arg3)) {
            return [arg1, {}, arg3];
          }
          return [[], {}, null];
      }
    }

    /**
     * Deletes the requested models.
     *
     * @function (arg1, arg2, [arg3], [arg4])
     * @private
     * @param {Object}          the collection object,
     * @param {Array}           the list of ids,
     * @param {Object}          the optionale parameters,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _delete(col, ...args) {
      const [list, options, callback] = _delArgs(...args)
          , { url }                   = col
          ;

      // Quick return if the list is empty:
      if (list.length === 0) {
        if (!options.silent) col.$fire('delete', []);
        if (callback) callback(null, []);
        return;
      }

      // Compute the query (form must be: ids=id1,id2,...,idn)
      let query = '?ids=';
      for (let i = 0; i < list.length; i++) {
        query += i < list.length - 1 ? `${list[i]},` : `${list[i]}`;
      }

      const opts = {
        method: 'DELETE',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
      };

      const type = options.type === 'text' ? 'text' : 'json';
      F.fetch(`${url}${query}`, opts, type, (err, data) => {
        if (err) {
          if (callback) callback(err);
          return;
        }
        const ids = [];
        if (_.isLiteralObject(data) && _.isArray(data.deleted)) {
          data.deleted.forEach((item) => {
            ids.push(item.id);
          });
        }

        const rmod = col.$remove(ids, { silent: true });
        if (!options.silent) col.$fire('delete', rmod);
        if (callback) callback(null, rmod);
      });
    }

    /**
     * Returns a model specified by a cid or an id.
     *
     * @function (arg1, arg2, [arg3])
     * @private
     * @param {Object}          the collection object,
     * @param {String/Number}   the cid or id,
     * @param {Object}          the options,
     * @returns {Object}        returns the requested model or null,
     * @since 0.0.0
     */
    function _get(col, id/* , options */) {
      if (!id) return null;

      for (let i = 0; i < col._models.length; i++) {
        if (col._models[i].cid === id || col._models[i]._attributes.id === id) {
          return col._models[i];
        }
      }
      return null;
    }


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Returns a model specified by a cid or an id.
       *
       * @method (arg1, arg2, [arg3])
       * @public
       * @param {Object}          the collection object,
       * @param {String/Number}   the id or cid,
       * @param {Object}          the options,
       * @returns {Object}        returns the requested model,
       * @since 0.0.0
       */
      get(col, id, options) {
        return _get(col, id, options);
      },

      /**
       * Deletes the requested models.
       *
       * @method (arg1, arg2, [arg3], [arg4])
       * @public
       * @param {Object}          the collection object,
       * @param {Array}           the list of ids,
       * @param {Object}          the optionale parameters,
       * @param {Function}        the function to call at the completion,
       * @returns {Object}        returns this,
       * @since 0.0.0
       */
      delete(col, ...args) {
        _delete(col, ...args);
        return this;
      },

      /**
       * Returns the next model in a collection from the passed-in model.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the collection,
       * @param {String/Number} the cid or id of the model,
       * @returns {Object}      returns the found model or null,
       * @since 0.0.0
       */
      next(collection, id) {
        return _nextOrprevious(collection, id, true);
      },

      /**
       * Returns the previous model in a collection from the passed-in model.
       *
       * @method (arg1, arg2)
       * @public
       * @param {Object}        the collection,
       * @param {String/Number} the cid or id of the model,
       * @returns {Object}      returns the found model or null,
       * @since 0.0.0
       */
      previous(collection, id) {
        return _nextOrprevious(collection, id);
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.collection.private.util2, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 18, path: 'src/components/collection/private/util3.js', import: [12, 9] */
  (function() {
    /** ************************************************************************
     *
     * Implements a few utility primitives.
     *
     * util.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _getSaveArgs                decodes the save arguments,
     *  . _save                       adds or updates a set of models on the server,
     *
     *
     * Public Static Methods:
     *  . save                        adds or updates a set of models on the server,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const { _ } = $__TREE.src.libs;
    const F = $__TREE.src.sync.main;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Decodes the save arguments.
     *
     * @function (arg1, arg2, [arg3], [arg4])
     * @private
     * @param {String}          the where clause,
     * @param {Object}          the parameters,
     * @param {Object}          the fetch options,
     * @param {Function}        the function to call at the completion
     * @returns {Array}         returns an array with where, params, options, callback,
     * @since 0.0.0
     */
    function _getSaveArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;

      switch (args.length) {
        case 0:
          return [null, null, {}, null];

        case 1:
          return [null, null, {}, null];

        case 2:
          if (_.isString(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2, {}, null];
          }
          return [null, null, {}, null];

        case 3:
          if (_.isString(arg1) && _.isLiteralObject(arg2) && _.isLiteralObject(arg3)) {
            return [arg1, arg2, arg3, null];
          }
          if (_.isString(arg1) && _.isLiteralObject(arg2) && _.isFunction(arg3)) {
            return [arg1, arg2, {}, arg3];
          }
          return [arg1, arg2, {}, null];

        default:
          if (_.isString(arg1)
              && _.isLiteralObject(arg2)
              && _.isLiteralObject(arg3)
              && _.isFunction(arg4)) {
            return [arg1, arg2, arg3, arg4];
          }
          if (_.isString(arg1) && _.isLiteralObject(arg2)) {
            return [arg1, arg2, {}, null];
          }
          return [null, null, {}, null];
      }
    }

    /**
     * Adds or updates a set of models on the server.
     *
     * @function (arg1, arg2, arg3, arg4, [arg5], [arg6])
     * @private
     * @param {Object}          the collection object,
     * @param {String}          the server url/api,
     * @param {String}          the where clause,
     * @param {Object}          the params to update,
     * @param {Object}          the options,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _save(col, url, ...args) {
      const [where, params, options, callback] = _getSaveArgs(...args);

      const opts = {
        method: 'POST',
        headers: {
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ where, params }),
      };

      const type = options.type === 'text' ? 'text' : 'json';
      F.fetch(url, opts, type, (err, data) => {
        if (err) {
          if (callback) callback(err);
          return;
        }

        // Update collection
        if (_.isArray(data)) {
          let m;
          let keys;
          // Update the models that exist in the collection:
          for (let i = 0; i < data.length; i++) {
            if (data[i].id) {
              m = col.$get(data[i].id);
              if (m) {
                keys = Object.keys(data[i]);
                for (let j = 0; j < keys.length; j++) {
                  if (keys[j] !== 'id') {
                    m.$set(keys[j], data[i][keys[j]]);
                  }
                }
              }
            }
          }
          if (!options.silent) col.$fire('save', data);
          if (callback) callback(null, data);
          return;
        }
        if (!options.silent) col.$fire('save', []);
        if (callback) callback(null, []);
      });
    }


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Adds or updates a set of models on the server.
       *
       * @method (arg1, arg2, arg3, arg4, [arg5], [arg6])
       * @public
       * @param {Object}          the collection object,
       * @param {String}          the server url/api,
       * @param {String}          the where clause,
       * @param {Object}          the params to update,
       * @param {Object}          the options,
       * @param {Function}        the function to call at the completion,
       * @returns {Object}        returns this,
       * @since 0.0.0
       */
      save(col, url, ...args) {
        _save(col, url, ...args);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.collection.private.util3, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 19, path: 'src/components/router/util.js', import: [7] */
  (function() {
    /** ************************************************************************
     *
     * Implements utility primitives.
     *
     * util.js is just a literal object that contains a set of functions. It
     * can't be intantiated.
     *
     * Private Functions:
     *  . _decodeQuery                decodes the query,
     *  . _decodeParams               decodes the params,
     *  . _route                      processes the routes,
     *
     *
     * Public Static Methods:
     *  . startListeningHashChange    starts the router,
     *  . stopListeningHashChange     stops the router,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules
    const History = $__TREE.src.components.history.main;


    // -- Local Constants


    // -- Local Variables


    // -- Private Functions ----------------------------------------------------

    /**
     * Decodes the query.
     *
     * Nota:
     * Decodes the query from a simple route. For instance the route
     * 'page1/doc' and the url 'page1/doc/?id=1&qty=123' gives the params
     *  '{ id: 1, qty: 123 }'.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Array}           the list of the defined routes,
     * @param {String}          the clicked url,
     * @returns {Array}         returns the matching route and the params,
     * @since 0.0.0
     */
    function _decodeQuery(routes, url) {
      let route = url.slice(0, url.indexOf('?'));
      route = route.slice(-1) === '/' ? route.slice(0, -1) : route;

      if (routes[route]) {
        const query = {};
        url.slice(url.indexOf('?') + 1).split('&').forEach((item) => {
          const q = item.split('=');
          if (q.length === 2 && q[0].length > 0) {
            let value = q[1];
            if (/^\d+$/.test(value)) {
              value = parseInt(value, 10);
            }
            query[q[0]] = value;
          }
        });
        return [route, query];
      }

      return [null, null];
    }

    /**
     * Decodes the params.
     *
     * Nota:
     * Decodes params from a route defined with '/:'. For instance the route
     * 'page1/doc/:id/:qty' and the url 'page1/doc/1/123' gives the params
     *  '{ id: 1, qty: 123 }'.
     *
     * @function (arg1, arg2)
     * @private
     * @param {Array}           the list of the defined routes,
     * @param {String}          the clicked url,
     * @returns {Array}         returns the matching route and the params,
     * @since 0.0.0
     */
    function _decodeParams(routes, url) {
      let route;
      let rpath;
      let match = false;

      const r = Object.keys(routes);
      for (let i = 0; i < r.length; i++) {
        if (r[i].includes('/:')) {
          rpath = r[i].split('/:');
          if (url.startsWith(`${rpath[0]}/`)) {
            route = r[i];
            match = true;
            break;
          }
        }
      }

      if (match) {
        // It matches, decode the params:
        // page3/doc/1/123
        //          |____| these are the params
        const [path] = rpath;
        const params = {};
        const values = url.slice(path.length + 1).split('/');
        for (let i = 1; i < rpath.length; i++) {
          let value = values[i - 1];
          if (/^\d+$/.test(value)) {
            value = parseInt(value, 10);
          }
          params[rpath[i]] = value;
        }
        return [route, params];
      }
      return [null, null];
    }

    /**
     * Processes the routes.
     *
     * Nota:
     * If this._replace is set to true, we won't store the hash change in the
     * history but only for once. When we turn it off. So, the caller must
     * turn this._replace true before changing the url.
     *
     * The philosophy is the same for this._trigger. By default, it is true. If
     * the caller doesn't want to trigger the route, it has to set false before.
     * And, when executed, this function turn it in the default state.
     *
     * @function ()
     * @private
     * @param {}                -,
     * @param {}                -,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _route() {
      /* eslint-disable-next-line no-restricted-globals */
      const url  = location.hash.slice(1);

      let route;
      let params;
      if (this.routes[url]) {
        route = url;
      } else {
        [route, params] = url.includes('?')
          ? _decodeQuery(this.routes, url)
          : _decodeParams(this.routes, url);
      }
      // If the route is unknown, we redirect to the 'home' page for
      // avoiding a blank page!
      route = typeof route === 'string' ? route : '';

      const fn = this[this.routes[route]];
      if (typeof fn !== 'function') {
        throw new Error(`Spine.Router: this direction "${fn}" does not match a function!`);
      }
      if (History.isHistoryRunning() && !this._replace) {
        History.push(url);
      }
      this._replace = false;

      if (this._trigger) {
        // fn.bind(this)();
        this.$execute(fn, params, route, url);
      } else {
        this._trigger = true;
      }
    }


    // -- Public Static Methods ------------------------------------------------

    const Util = {

      /**
       * Starts the router.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the router object,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      startListeningHashChange(router) {
        this._route = _route.bind(router);
        // Listens on hash change and on page load:
        window.addEventListener('hashchange', this._route);
        window.addEventListener('load', this._route);
        return this;
      },

      /**
       * Stops the router.
       *
       * @method (arg1)
       * @public
       * @param {Object}        the router object,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      stopListeningHashChange() {
        window.removeEventListener('hashchange', this._route);
        window.removeEventListener('load', this._route);
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.components.router.util, Util);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());

  /* index: 21, path: 'src/sync/fetch.js', import: [] */
  (function() {
    /** ************************************************************************
     *
     * Retrieves data from the server.
     * (this file is just a copy and paste of the file './src/private/fetch.js'
     * extracted from PicoQ v1.0.1 with one exception: fetch does not return
     * a promise)
     *
     * fetch.js is just a literal object that contains a set of functions.
     * It can't be instantiated.
     *
     * Private Functions:
     *  . _getArgs                    returns the named fetch arguments,
     *  . _fetchServer                fetches data on the server,
     *  .  _fetch                     formats returned value,
     *
     *
     * Public Static Methods:
     *  . fetch                       fetches data on the server,
     *
     *
     *
     * @namespace    -
     * @dependencies none
     * @exports      -
     * @author       -
     * @since        0.0.0
     * @version      -
     * ********************************************************************** */
    /* - */
    /* eslint-disable one-var, semi-style, no-underscore-dangle */


    // -- Vendor Modules


    // -- Local Modules


    // -- Local Constants


    // -- Local Variables


    // -- Private functions ----------------------------------------------------

    /**
     * Returns the named fetch arguments.
     *
     * @function (...args)
     * @private
     * @param {...}             the optional arguments [url, options, type, callback],
     * @returns {}              -,
     * @since 0.0.0
     */
    function _getArgs(...args) /* istanbul ignore next */{
      const [arg1, arg2, arg3, arg4] = args;

      switch (args.length) {
        case 0:
          return [null, null, null, null];

        case 1:
          if (typeof arg1 === 'string') {
            return [arg1, {}, null, null];
          }
          return [null, null, null, null];

        case 2:
          if (typeof arg1 === 'string') {
            if (typeof arg2 === 'object' && arg2.method) {
              return [arg1, arg2, null, null];
            }
            if (typeof arg2 === 'string') {
              return [arg1, {}, arg2, null];
            }
            if (typeof arg2 === 'function') {
              return [arg1, {}, null, arg2];
            }
            return [arg1, {}, null, null];
          }
          return [null, null, null, null];

        case 3:
          if (typeof arg1 === 'string') {
            if (typeof arg2 === 'object' && arg2.method) {
              if (typeof arg3 === 'string') {
                return [arg1, arg2, arg3, null];
              }
              if (typeof arg3 === 'function') {
                return [arg1, arg2, null, arg3];
              }
              return [arg1, arg2, null, null];
            }

            if (typeof arg2 === 'string') {
              if (typeof arg3 === 'function') {
                return [arg1, {}, arg2, arg3];
              }
              return [arg1, {}, arg2, null];
            }

            if (typeof arg3 === 'function') {
              return [arg1, {}, null, arg3];
            }
            return [arg1, {}, null, null];
          }
          return [null, null, null, null];

        case 4:
          if ((typeof arg1 === 'string')
            && typeof arg2 === 'object' && arg2.method
            && typeof arg3 === 'string'
            && typeof arg4 === 'function') {
            return [arg1, arg2, arg3, arg4];
          }
          if ((typeof arg1 === 'string')
            && typeof arg2 === 'object' && arg2.method
            && typeof arg3 === 'string') {
            return [arg1, arg2, arg3, null];
          }
          return [null, null, null, null];

        default:
          // > 4
          if ((typeof arg1 === 'string')
            && typeof arg2 === 'object' && arg2.method
            && typeof arg3 === 'string'
            && typeof arg4 === 'function') {
            return [arg1, arg2, arg3, arg4];
          }
          return [null, null, null, null];
      }
    }

    /**
     * Fetches data on the server.
     *
     * @function (arg1, arg2, arg3)
     * @public
     * @param {String}          the server url & api,
     * @param {Object}          the fetch parameters,
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    // function _oldfetch(url, options, type, callback) /* istanbul ignore next */{
    //   fetch(url, options)
    //     .then((resp) => {
    //       if (resp.ok) {
    //         return type === 'json' ? resp.json() : resp.text();
    //       }
    //       return Promise.reject(resp);
    //     })
    //     .then((data) => {
    //       if (callback) {
    //         callback(null, data);
    //       } else {
    //         /* eslint-disable-next-line no-console */
    //         console.log('warning: fetch gets no callback!');
    //       }
    //     })
    //     .catch((err) => {
    //       if (callback) {
    //         callback(err);
    //       } else {
    //         /* eslint-disable-next-line no-console */
    //         console.log('warning: fetch gets no callback!');
    //       }
    //     });
    // }
    function _fetchServer(url, options, callback) /* istanbul ignore next */{
      let status;

      fetch(url, options)
        .then((response) => {
          if (response.ok) {
            return response.text();
          }
          status = response.status;
          return Promise.reject(response);
        })
        .then((data) => {
          callback(null, data);
        })
        .catch((error) => {
          if (error && error.text) {
            error.text()
              .then((err) => { callback(err || { status, message: 'none!', statusText: 'none!' }); })
            ;
          } else {
            console.log(error);
          }
        })
      ;
    }

    /**
     * Fetches data.
     *
     * @function (arg1, arg2, arg3, arg4)
     * @public
     * @param {String}          the server url & api,
     * @param {Object}          the fetch parameters,
     * @param {String}          the returned format (string or json),
     * @param {Function}        the function to call at the completion,
     * @returns {}              -,
     * @since 0.0.0
     */
    function _fetch(url, options, type, callback) {
      _fetchServer(url, options, (err, data) => {
        if (err && type === 'json') {
          let nerr;
          try {
            nerr = JSON.parse(err);
            // statusText is to keep compatibility with previous versions.
            // (to be removed by the end of 2023)
            nerr.statusText = nerr.message;
          } catch (e) {
            nerr = { status: '40x', message: err, statusText: err };
          }
          callback(nerr);
          return;
        }

        if (err) {
          callback(err);
          return;
        }

        if (type === 'json') {
          let ndata;
          try {
            ndata = JSON.parse(data);
          } catch (e) {
            ndata = data;
          }
          callback(null, ndata);
          return;
        }

        callback(null, data);
      });
    }


    // -- Public Static Methods ------------------------------------------------

    const Fetch = {

      /**
       * Fetches data on the server.
       *
       * @method (arg1, [arg2], [arg3], [arg4])
       * @public
       * @param {String}        the server url,
       * @param {Object}        the fetch options,
       * @param {String}        the type of file (json or text),
       * @param {String}        the function to call at the completion,
       * @returns {Object}      returns this,
       * @since 0.0.0
       */
      fetch(...args) /* istanbul ignore next */{
        const [url, options, type, callback] = _getArgs(...args);
        _fetch(url, options, type || 'json', (err, data) => {
          if (callback) callback(err, data);
        });
        return this;
      },
    };


    // -- Export
    $__TREE.extend($__TREE.src.sync.fetch, Fetch);

    /* eslint-enable one-var, semi-style, no-underscore-dangle */
  }());


  /* eslint-disable no-shadow */
  function $__TREE_RUN_EMBED_LIB() {
    /* index: 11, path: 'node_modules/@mobilabs/kzlog/_dist/lib/kzlog.js' */
    /* export: KZlog, link: 'libin.kzlog' */
    /*! ****************************************************************************
     * KZlog v1.0.4
     *
     * A minimal lightweight logging library for JavaScript.
     * (you can download it from npm or github repositories)
     * Copyright (c) 2024 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
     * Released under the MIT license. You may obtain a copy of the License
     * at: http://www.opensource.org/licenses/mit-license.php).
     * Built from ES6lib v2.1.1.
     * ************************************************************************** */
    // ESLint declarations
    /* - */
    /* eslint strict: ["error", "function"] */
    (function(root, factory) {
      /* - */

      /* c8 ignore start */
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([''], factory);
      } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        /* eslint-disable-next-line no-param-reassign */
        module.exports = factory(root);
        /* eslint-disable-next-line no-param-reassign */
        root.KZlog = factory(root);
      } else {
        // Browser globals.
        /* eslint-disable-next-line no-param-reassign */
        root.KZlog = factory(root);
      }
      /* c8 ignore stop */
    }($__TREE.libin, (root) => {
      /* - */

      /** **************************************************************************
       * _head provides the list of the constants that are defined at the global
       * level of this module and are accessible to all. So, they are considered
       * as reserved words for this library.
       * ************************************************************************ */
      /* eslint-disable one-var, no-unused-vars, semi-style */

      let KZlog
        ;

      // Tree is an internal object that links all the internal modules.
      let LG = {};

      /* eslint-enable one-var, no-unused-vars, semi-style */

      /** **************************************************************************
       *
       * A lightweight logging library for JavaScript.
       *
       * kzlog.js is built upon the Prototypal Instantiation pattern. It
       * returns an object by calling its constructor. It doesn't use the new
       * keyword.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Constructor:
       *  . KZlog                       creates and returns the KZlog object,
       *
       *
       * Private Static Methods:
       *  . _setTestMode                returns internal objects for testing purpose,
       *
       *
       * Public Static Methods:
       *  . noConflict                  returns a reference to this KZlog object,
       *
       *
       * Public Methods:
       *  . whoami                      returns the library name and version,
       *  . help                        dumps, to the console, the on-line help,
       *  . setName                     updates the name of the module/library,
       *  . setLevel                    updates the threshold level,
       *  . setHighlight                updates the highlight mode,
       *  . trace                       dumps a trace message,
       *  . debug                       dumps a debug message,
       *  . info                        dumps a info message,
       *  . warn                        dumps a warn message,
       *  . error                       dumps a error message,
       *  . fatal                       dumps a fatal message,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants
        // Saves the previous value of the library variable, so that it can be
        // restored later on, if noConflict is used.
        const previousKZlog = root.KZlog
            ;


        // -- Local Variables
        let methods
          ;


        // -- Public ---------------------------------------------------------------

        /**
         * Returns the KZlog object.
         * (Prototypal Instantiation Pattern)
         *
         * @constructor (arg1, arg2, arg3)
         * @public
         * @param {String}        the name of the module/library to be printed,
         * @param {String}        the log level threshold,
         * @param {Boolean}       the highlight mode (true: color, false: B&W),
         * @returns {Object}      returns the KZlog object,
         * @since 0.0.0
         */
        KZlog = function(name, level, highlight) {
          const obj = Object.create(methods);
          obj._library = {
            name: 'KZlog',
            version: '1.0.4',
          };
          obj.name = name || 'unknown!';
          obj.level = level || 'trace';
          obj.highlight = highlight !== false;
          return obj;
        };

        // Attaches constants to KZlog that provide name and version of the lib.
        KZlog.NAME = 'KZlog';
        KZlog.VERSION = '1.0.4';


        // -- Private Static Methods -----------------------------------------------

        /**
         * Returns the internal objects for testing purpose.
         * (must not be deleted)
         *
         * @method ()
         * @private
         * @param {}              -,
         * @returns {Object}      returns a list of internal objects,
         * @since 0.0.0
         */
        KZlog._setTestMode = function() {
          return [];
        };


        // -- Public Static Methods ------------------------------------------------

        /**
         * Returns a reference to this KZlog object.
         * (must not be deleted)
         *
         * Nota:
         * Running KZlog in noConflict mode, returns the KZlog variable to its
         * _ previous owner.
         *
         * @method ()
         * @public
         * @param {}              -,
         * @returns {Object}      returns the KZlog object,
         * @since 0.0.0
         */
        KZlog.noConflict = function() {
          /* eslint-disable-next-line no-param-reassign */
          root.KZlog = previousKZlog;
          return this;
        };


        // -- Public Methods -------------------------------------------------------

        methods = {

          /**
           * Returns the library name and version.
           * (must not be deleted)
           *
           * @method ()
           * @public
           * @param {}            -,
           * @returns {Object}    returns the library name and version,
           * @since 0.0.0
           */
          whoami() {
            return this._library;
          },

          /**
           * Dumps, to the console, the on-line help.
           *
           * @function ()
           * @public
           * @param {}            -,
           * @returns {}          -,
           * @since 0.0.0
           */
          help() {
            const help = ['',
              'Prints a log message formatted as: [year-month-day] [level] name message,',
              'Methods:',
              '  help(): print this message,',
              '  version(): return the version number,',
              '  setName(name): set the name',
              '  setLevel(level): set the level',
              '  setHighlight()highlight: set the highlight mode',
              '  trace(msg): print the trace message,',
              '  debug(msg): print the debug message,',
              '  info(msg): print the info message,',
              '  warn(msg): print the warn message,',
              '  error(msg): print the error message,',
              '  fatal(msg): print the fatal message,',
              '',
            ].join('\n');

            /* eslint-disable-next-line no-console */
            console.log(help);
          },

          /**
           * Updates the name of the module/library.
           *
           * @function (arg1)
           * @public
           * @param {String}      the name of the library running the KZlog,

           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          setName(name) {
            this.name = name || 'unknown!';
            return this;
          },

          /**
           * Updates the the threshold level.
           *
           * @function (arg1)
           * @public
           * @param {String}      the the threshold level,

           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          setLevel(level) {
            this.level = level || 'trace';
            return this;
          },

          /**
           * Updates the the highlight mode.
           *
           * @function (arg1)
           * @public
           * @param {Boolean}     the the highlight mode,

           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          setHighlight(highlight) {
            this.highlight = highlight !== false;
            return this;
          },

          /**
           * Dumps a trace message.
           *
           * @function (arg1)
           * @public
           * @param {String}      the message,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          trace(msg) {
            LG.print(this, msg, 'trace');
            return this;
          },

          /**
           * Dumps a debug message.
           *
           * @function (arg1)
           * @public
           * @param {String}      the message,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          debug(msg) {
            LG.print(this, msg, 'debug');
            return this;
          },

          /**
           * Dumps an info message.
           *
           * @function (arg1)
           * @public
           * @param {String}      the message,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          info(msg) {
            LG.print(this, msg, 'info');
            return this;
          },

          /**
           * Dumps an warn message.
           *
           * @function (arg1)
           * @public
           * @param {String}      the message,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          warn(msg) {
            LG.print(this, msg, 'warn');
            return this;
          },

          /**
           * Dumps an error message.
           *
           * @function (arg1)
           * @public
           * @param {String}      the message,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          error(msg) {
            LG.print(this, msg, 'error');
            return this;
          },

          /**
           * Dumps a fatal message.
           *
           * @function (arg1)
           * @public
           * @param {String}      the message,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          fatal(msg) {
            LG.print(this, msg, 'fatal');
            return this;
          },
        };

        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      /** **************************************************************************
       *
       * Implements the functions used by KZlog.
       *
       * log.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . _default                    returns the default level,
       *  . _levels                     returns the defined levels,
       *
       *
       * Public Static Methods:
       *  . print                       dumps, to the console, the logging message,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants
        const DEFAULT_LEVEL = 'trace'
            , LEVELS = ['trace', 'debug', 'info', 'warn', 'error', 'fatal', 'off']
            ;


        // -- Local Variables


        // -- Private Functions ----------------------------------------------------

        /**
         * Returns the default level.
         *
         * @function ()
         * @private
         * @param {}              -,
         * @returns {Array}       returns the default level,
         * @since 0.0.0
         */
        /* istanbul ignore next */
        function _default() {
          return DEFAULT_LEVEL;
        }

        /**
         * Returns the defined levels.
         *
         * @function ()
         * @private
         * @param {}              -,
         * @returns {Array}       returns the defined levels,
         * @since 0.0.0
         */
        function _levels() {
          return LEVELS;
        }


        // -- Public Static Methods ------------------------------------------------

        LG = {

          /**
           * Dumps, to the console, the logging message.
           *
           * @method (arg1, arg2)
           * @public
           * @param {Object}    the log object,
           * @param {String}    the message to print,
           * @param {String}    the level of the message,
           * @returns {}        -,
           * @since 0.0.0
           */
          /* eslint-disable no-param-reassign, no-console */
          print(log, msg, currentlevel) {
            const levels = _levels()
                , colors = [32, 36, 34, 33, 35, 31, 0]
                , date   = new Date()
                ;

            let stringDate = `[${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}  `;
            stringDate += `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}:${date.getMilliseconds()}`;
            stringDate += ']';

            if (!log.level) {
              /* istanbul ignore next */
              log.level = _default();
            }

            if (log.highlight === undefined) {
              /* istanbul ignore next */
              log.highlight = true;
            }

            let message;
            if (levels.indexOf(currentlevel) >= levels.indexOf(log.level)) {
              if (log.highlight === true) {
                const ctags = `\u001b[1;${colors[levels.indexOf(currentlevel)]}m`;
                const ctage = '\u001b[0m';

                message = `${stringDate} [${ctags}${currentlevel}${ctage}] `;
                message += `${log.name}: ${msg}`;
              } else {
                /* istanbul ignore next */
                message = `${stringDate} [${currentlevel}] ${log.name}: ${msg}`;
              }
              console.log(message);
              if (typeof msg === 'object') {
                // to visualize content of the object instead of [object Object] only.
                /* istanbul ignore next */
                console.log(msg);
              }
            }
          },
          /* eslint-enable no-param-reassign, no-console */
        };


        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      // Returns the library name:
      return KZlog;
    }));
    /* index: 20, path: 'node_modules/@mobilabs/messenger/_dist/lib/messenger.js' */
    /* export: Messenger, link: 'libin.messenger' */
    /*! ****************************************************************************
     * Messenger v1.0.4
     *
     * A tiny Javascript library to handle messages that carry a payload.
     * (you can download it from npm or github repositories)
     * Copyright (c) 2024 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
     * Released under the MIT license. You may obtain a copy of the License
     * at: http://www.opensource.org/licenses/mit-license.php).
     * Built from ES6lib v2.1.1.
     * ************************************************************************** */
    // ESLint declarations
    /* - */
    /* eslint strict: ["error", "function"] */
    (function(root, factory) {
      /* - */

      /* c8 ignore start */
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([''], factory);
      } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        /* eslint-disable-next-line no-param-reassign */
        module.exports = factory(root);
        /* eslint-disable-next-line no-param-reassign */
        root.Messenger = factory(root);
      } else {
        // Browser globals.
        /* eslint-disable-next-line no-param-reassign */
        root.Messenger = factory(root);
      }
      /* c8 ignore stop */
    }($__TREE.libin, (root) => {
      /* - */

      /** **************************************************************************
       * _head provides the list of the constants that are defined at the global
       * level of this module and are accessible to all. So, they are considered
       * as reserved words for this library.
       * ************************************************************************ */
      /* eslint-disable one-var, no-unused-vars, semi-style */

      let Messenger
        , TM
        ;

      /* eslint-enable one-var, no-unused-vars, semi-style */

      /** **************************************************************************
       *
       * Defines the Messenger library.
       *
       * messenger.js is built upon the Prototypal Instantiation pattern. It
       * returns an object by calling its constructor. It doesn't use the new
       * keyword.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Constructor:
       *  . Messenger                   creates and returns the Messenger object,
       *
       *
       * Private Static Methods:
       *  . _setTestMode                returns internal objects for testing purpose,
       *
       *
       * Public Static Methods:
       *  . noConflict                  returns a reference to this Messenger object,
       *
       *
       * Public Methods:
       *  . whoami                      returns the library name and version,
       *  . subscribe                   adds an event listener,
       *  . subscribeOnce               adds an event listener that is fired once,
       *  . unsubscribe                 removes an event listener,
       *  . publish                     fires an event,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants
        // Saves the previous value of the library variable, so that it can be
        // restored later on, if noConflict is used.
        const previousMessenger = root.Messenger
            ;


        // -- Local Variables
        let methods
          ;


        // -- Public ---------------------------------------------------------------

        /**
         * Returns the Messenger object.
         * (Prototypal Instantiation Pattern)
         *
         * @constructor ()
         * @public
         * @param {}              -,
         * @returns {Object}      returns the Messenger object,
         * @since 0.0.0
         */
        Messenger = function() {
          const obj = Object.create(methods);
          obj._library = {
            name: 'Messenger',
            version: '1.0.4',
          };
          // Initializes the message database to empty:
          obj._db = {};
          return obj;
        };

        // Attaches constants to Messenger that provide name and version of the lib.
        Messenger.NAME = 'Messenger';
        Messenger.VERSION = '1.0.4';


        // -- Private Static Methods -----------------------------------------------

        /**
         * Returns the internal objects for testing purpose.
         * (must not be deleted)
         *
         * @method ()
         * @private
         * @param {}              -,
         * @returns {Object}      returns a list of internal objects,
         * @since 0.0.0
         */
        Messenger._setTestMode = function() {
          return [];
        };


        // -- Public Static Methods ------------------------------------------------

        /**
         * Returns a reference to this Messenger object.
         * (must not be deleted)
         *
         * Nota:
         * Running Messenger in noConflict mode, returns the Messenger variable to
         * its previous owner.
         *
         * @method ()
         * @public
         * @param {}              -,
         * @returns {Object}      returns the Messenger object,
         * @since 0.0.0
         */
        Messenger.noConflict = function() {
          /* eslint-disable-next-line no-param-reassign */
          root.Messenger = previousMessenger;
          return this;
        };


        // -- Public Methods -------------------------------------------------------

        methods = {

          /**
           * Returns the library name and version.
           * (must not be deleted)
           *
           * @method ()
           * @public
           * @param {}            -,
           * @returns {Object}    returns the library name and version,
           * @since 0.0.0
           */
          whoami() {
            return this._library;
          },

          /**
           * Adds an event listener.
           *
           * @method (arg1, arg2)
           * @public
           * @param {String}      the event,
           * @param {Function}    the event handler,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          subscribe(event, listener) {
            TM.subscribe(this._db, event, listener);
            return this;
          },

          /**
           * Adds an event listener that is fired once.
           *
           * @method (arg1, arg2)
           * @public
           * @param {String}      the event,
           * @param {Function}    the event handler,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          subscribeOnce(event, listener) {
            TM.subscribeOnce(this._db, event, listener);
            return this;
          },

          /**
           * Removes an event listener.
           *
           * @method (arg1, arg2)
           * @public
           * @param {String}      the event,
           * @param {Function}    the event handler,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          unsubscribe(event, listener) {
            TM.unsubscribe(this._db, event, listener);
            return this;
          },

          /**
           * Fires an event.
           *
           * @method (arg1, arg2)
           * @public
           * @param {String}      the event,
           * @param {Object}      the payload,
           * @returns {Object}    returns this,
           * @since 0.0.0
           */
          publish(event, payload) {
            TM.publish(this._db, event, payload);
            return this;
          },
        };

        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      /** **************************************************************************
       *
       * Implements the Messenger methods.
       *
       * messenger.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . _schema                     returns the event db schema,
       *  . _add                        adds a new event into the db,
       *  . _addEvents                  adds the events to the db,
       *  . _publish                    fires an event,
       *  . _unsubscribe                removes an event listener,
       *  . _subscribeOnce              adds an event listener that is fired once,
       *  . _subscribe                  adds an event listener,
       *
       *
       * Private Static Methods:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . subscribe                   adds an event listener,
       *  . subscribeOnce               adds an event listener that is fired once,
       *  . unsubscribe                 removes an event listener,
       *  . publish                     fires an event,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Private Functions ----------------------------------------------------

        /**
         * Returns the event db schema.
         *
         * @function ()
         * @private
         * @returns {Object}      returns the schema,
         * @since 0.0.0
         */
        function _schema() {
          return {
            listeners: [],
            listenersOnce: [],
          };
        }

        /**
         * Adds a new event into the db.
         *
         * @function (arg1, arg2)
         * @private
         * @param {Object}        the event db,
         * @param {String}        the event,
         * @returns {}            -,
         * @since 0.0.0
         */
        function _add(db, e) {
          if (!Object.prototype.hasOwnProperty.call(db, e)) {
            /* eslint-disable-next-line no-param-reassign */
            db[e] = _schema();
          }
        }

        /**
         * Adds the events to the db.
         *
         * @function (arg1, arg2)
         * @private
         * @param {Object}        the event db,
         * @param {String/Array}  the event,
         * @returns {}            -,
         * @since 0.0.0
         */
        function _addEvents(db, e) {
          if (typeof e === 'string') {
            _add(db, e);
          }
        }

        /**
         * Fires an event.
         *
         * @function (arg1, arg2, arg3)
         * @private
         * @param {Object}        the event db,
         * @param {String}        the event,
         * @param {Object}        the payload,
         * @returns {}            -,
         * @since 0.0.0
         */
        function _publish(db, event, payload) {
          if (typeof event === 'string' && Object.prototype.hasOwnProperty.call(db, event)) {
            // Fires all the 'classic' listeners:
            for (let i = 0; i < db[event].listeners.length; i++) {
              db[event].listeners[i](payload);
            }
            // Fires all the listeners for once:
            for (let i = 0; i < db[event].listenersOnce.length; i++) {
              db[event].listenersOnce[i](payload);
            }
            // Remove all the event listeners for listener once:
            db[event].listenersOnce.splice(0, db[event].listenersOnce.length);
          }
        }

        /**
         * Removes an event listener.
         *
         * @function (arg1, arg2, arg3)
         * @private
         * @param {Object}        the event db,
         * @param {String}        the event,
         * @param {Function}      the listener,
         * @returns {}            -,
         * @since 0.0.0
         */
        function _unsubscribe(db, event, listener) {
          let index;

          if (typeof event === 'string'
              && typeof listener === 'function'
              && Object.prototype.hasOwnProperty.call(db, event)) {
            index = db[event].listeners.indexOf(listener);
            if (index >= 0) {
              db[event].listeners.splice(index, 1);
            }
            index = db[event].listenersOnce.indexOf(listener);
            if (index >= 0) {
              db[event].listenersOnce.splice(index, 1);
            }
          }
        }

        /**
         * Adds an event listener that is fired once.
         *
         * @function (arg1, arg2, arg3, arg4)
         * @private
         * @param {Object}        the event db,
         * @param {String}        the event,
         * @param {Function}      the listener,
         * @param {Boolean}       listens for any events if true, registered otherwise,
         * @returns {}            -,
         * @since 0.0.0
         */
        function _subscribeOnce(db, event, listener) {
          _addEvents(db, event);
          if (typeof event === 'string'
              && typeof listener === 'function'
              && Object.prototype.hasOwnProperty.call(db, event)) {
            db[event].listenersOnce.push(listener);
          }
        }

        /**
         * Adds an event listener.
         *
         * @function (arg1, arg2, arg3, arg4)
         * @private
         * @param {Object}        the event db,
         * @param {String}        the event,
         * @param {Function}      the listener,
         * @param {Boolean}       listens for any events if true, registered otherwise,
         * @returns {}            -,
         * @since 0.0.0
         */
        function _subscribe(db, event, listener) {
          _addEvents(db, event);
          if (typeof event === 'string'
              && typeof listener === 'function'
              && Object.prototype.hasOwnProperty.call(db, event)) {
            db[event].listeners.push(listener);
          }
        }


        // -- Public Static Methods ------------------------------------------------

        TM = {

          /**
           * Adds an event listener.
           *
           * @method (arg1, arg2, arg3)
           * @public
           * @param {Object}      the event db,
           * @param {String}      the event,
           * @param {Function}    the event handler,
           * @returns {}          -,
           * @since 0.0.0
           */
          subscribe(db, event, listener) {
            _subscribe(db, event, listener);
          },

          /**
           * Adds an event listener that is fired once.
           *
           * @method (arg1, arg2, arg3)
           * @public
           * @param {Object}      the event db,
           * @param {String}      the event,
           * @param {Function}    the event handler,
           * @returns {}          -,
           * @since 0.0.0
           */
          subscribeOnce(db, event, listener) {
            _subscribeOnce(db, event, listener);
          },

          /**
           * Removes an event listener.
           *
           * @method (arg1, arg2, arg3)
           * @public
           * @param {Object}      the event db,
           * @param {String}      the event,
           * @param {Function}    the event handler,
           * @returns {}          -,
           * @since 0.0.0
           */
          unsubscribe(db, event, listener) {
            _unsubscribe(db, event, listener);
          },

          /**
           * Fires an event.
           *
           * @method (arg1, arg2, arg3)
           * @public
           * @param {Object}      the event db,
           * @param {String}      the event,
           * @param {Object}      the payload,
           * @returns {}          -,
           * @since 0.0.0
           */
          publish(db, event, payload) {
            _publish(db, event, payload);
          },
        };

        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      // Returns the library name:
      return Messenger;
    }));
    /* index: 22, path: 'node_modules/@mobilabs/overslash/_dist/lib/overslashobj.js' */
    /* export: Overslash, link: 'libin.overslashobj' */
    /*! ****************************************************************************
     * Overslash v1.0.9
     *
     * A tiny modular Javascript utility library.
     * (you can download it from npm or github repositories)
     * Copyright (c) 2024 Mobilabs <contact@mobilabs.fr> (http://www.mobilabs.fr).
     * Released under the MIT license. You may obtain a copy of the License
     * at: http://www.opensource.org/licenses/mit-license.php).
     * Built from ES6lib v2.1.3.
     * ************************************************************************** */
    // ESLint declarations
    /* - */
    /* eslint strict: ["error", "function"] */
    (function(root, factory) {
      /* - */

      /* c8 ignore start */
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([''], factory);
      } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        /* eslint-disable-next-line no-param-reassign */
        module.exports = factory(root);
        /* eslint-disable-next-line no-param-reassign */
        root.Overslash = factory(root);
      } else {
        // Browser globals.
        /* eslint-disable-next-line no-param-reassign */
        root.Overslash = factory(root);
      }
      /* c8 ignore stop */
    }($__TREE.libin, (root) => {
      /* - */

      /** **************************************************************************
       * _head provides the list of the constants that are defined at the global
       * level of this module and are accessible to all. So, they are considered
       * as reserved words for this library.
       * ************************************************************************ */
      /* eslint-disable one-var, no-unused-vars, semi-style */

      let Overslash
        , extend
        ;

      /* eslint-enable one-var, no-unused-vars, semi-style */

      /** **************************************************************************
       *
       * Provides the function 'extend' that is used to fill the object tree with
       * the public static or object methods when the Javascript VM browses the
       * library from the top to the bottom.
       *
       * extend.js is just a literal object that contains a set of functions.
       * It can't be instantiated.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . extend                      extends the passed-in object with new methods,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* - */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Public function ------------------------------------------------------

        /**
         * Extends the passed-in object with new methods.
         *
         * Nota: this function mutates object.
         *
         * @function (arg1, arg2)
         * @private
         * @param {Object}        the object to extend,
         * @param {Object}        an object containing a set of methods,
         * @returns {}            -,
         * @since 0.0.0
         */
        extend = function(object, methods) {
          const keys = Object.keys(methods);

          for (let i = 0; i < keys.length; i++) {
            /* eslint-disable-next-line no-param-reassign */
            object[keys[i]] = methods[keys[i]];
          }
        };

        // END OF IIFE
      }());
      /* - */

      /** **************************************************************************
       *
       * A tiny modular Javascript utility library.
       *
       * overslash.js is based on a variation of the basic.js pattern. The
       * properties are added dynamically. Thus, it can be divided in several
       * chunks of properties and the build can produces several versions of the
       * library by including or not some chunks.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Private Static Methods:
       *  . _setTestMode                returns internal objects for testing purpose,
       *
       *
       * Public Static Methods:
       *  . noConflict                  returns a reference to this Overslash object,
       *  . whoami                      returns the library name and version,
       *
       *
       *  Primitives types (mandatory):
       *  . isUndefined                 is a given variable undefined?
       *  . isNull                      is a given value null?
       *  . isBoolean                   is a given value a boolean?
       *  . isString                    is a given value a string?
       *  . isNumber                    is a given value a number?
       *  . isNaN                       is a given value NaN?
       *  . isOdd                       is a given value an odd number?
       *
       * Object types (mandatory):
       *  . isObject                    is a given variable an object?
       *  . isLiteralObject             is a given variable a literal object?
       *  . isFunction                  is a given variable a function?
       *  . isArray                     is a given value an array?
       *  . isMath                      is a given value a Math object?
       *  . isDate                      is a given value a Date?
       *  . isEmpty                     is a given array, string or object empty?
       *
       * Operations on Objects (optional):
       *  . clone                       clones a literal object or an array,
       *  . extend                      extends a given object with all the properties,
       *  . keys                        retrieves all the names of the object's,
       *  . forPropIn                   parses all the names of the object's,
       *  . assign                      extends source with target(s),
       *
       * Operations on Arrays (optional):
       *  . contains                    returns true if the array contains the passed-in value,
       *  . flatten                     flattens a nested array,
       *  . max                         returns the maximum value in the array,
       *  . min                         returns the minimum value in the array,
       *  . share                       returns the list of the elements in common,
       *  . pull                        removes the matching items from the passed-in array,
       *  . include                     returns the list of items included in the passed-in array,
       *  . partition                   returns matching and non matching criteria,
       *
       * Operations on functions (optional):
       *  . none,
       *
       * Operations on tokens (optional):
       *  . token                       returns a unique string pattern in base 36,
       *  . makeid                      returns a unique string pattern,
       *
       * Operations on csv blocks (optional):
       *  . csv2array                   converts an csv block to an array or arrays,
       *
       * Others (optional):
       *  . delay                       executes the passed-in function after a delay,
       *  . inRange                     checks if a number is between a range of numbers,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants
        // Saves the previous value of the library variable, so that it can be
        // restored later on, if noConflict is used.
        const previousOverslash = root.Overslash;


        // -- Local Variables


        // -- Public ---------------------------------------------------------------

        Overslash = {

          // Useful to retrieve the library name and version when it is
          // embedded in another library as an object:
          _library: { name: 'Overslash', version: '1.0.9' },


          // -- Private Static Methods ---------------------------------------------

          /**
           * Returns the internal objects for testing purpose.
           * (must not be deleted)
           *
           * @method ()
           * @private
           * @param {}            -,
           * @returns {Object}    returns a list of internal objects,
           * @since 0.0.0
           */
          _setTestMode() {
            return [];
          },


          // -- Public Static Methods ----------------------------------------------

          /**
           * Returns a reference to this Overslash object.
           * (must not be deleted)
           *
           * Nota:
           * Running Overslash in noConflict mode, returns the Overslash variable to its
           * _ previous owner.
           *
           * @function ()
           * @public
           * @param {}            -,
           * @returns {Object}    returns the Overslash object,
           * @since 0.0.0
           */
          noConflict() {
            /* eslint-disable-next-line no-param-reassign */
            root.Overslash = previousOverslash;
            return this;
          },

          /**
           * Returns the library name and version.
           * (must not be deleted)
           *
           * @method ()
           * @public
           * @param {}            -,
           * @returns {Object}    returns the library name and version,
           * @since 0.0.0
           */
          whoami() {
            return this._library;
          },
        };

        // Attaches constants to Overslash that provide name and version of the lib.
        Overslash.NAME = 'Overslash';
        Overslash.VERSION = '1.0.9';


        // Extends Overslash with new static methods.
        // extend(Overslash, {
        //   // see the methods folder.
        // });


        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      /** **************************************************************************
       *
       * Extends overslash with primitives types.
       *
       * primitives.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . isUndefined                 is a given variable undefined?
       *  . isNull                      is a given value null?
       *  . isBoolean                   is a given value a boolean?
       *  . isString                    is a given value a string?
       *  . isNumber                    is a given value a number?
       *  . isNaN                       is a given value NaN?
       *  . isOdd                       is a given value an odd number?
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* - */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Public Static Methods ------------------------------------------------

        extend(Overslash, {
          /**
           * Is a given variable undefined?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isUndefined(obj) {
            return obj === undefined;
          },

          /**
           * Is a given value null?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isNull(obj) {
            return obj === null;
          },

          /**
           * Is a given value a boolean?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isBoolean(obj) {
            return obj === true || obj === false || Object.prototype.toString.call(obj) === '[object Boolean]';
          },

          /**
           * Is a given value a string?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isString(obj) {
            return Object.prototype.toString.call(obj) === '[object String]';
          },

          /**
           * Is a given value a number?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isNumber(obj) {
            return Object.prototype.toString.call(obj) === '[object Number]';
          },

          /**
           * Is a given value NaN?
           * (NaN is the only number which does not equal itself)
           * (copied from: http://underscorejs.org)
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isNaN(obj) {
            return this.isNumber(obj) && obj !== +obj;
          },

          /**
           * Is a given value an odd number?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true (odd), false (even) or undefined (not a number),
           * @since 0.0.0
           */
          /* eslint-disable no-void */
          isOdd(obj) {
            const n = obj % 2;
            return obj === parseFloat(obj) ? !!n : void 0;
          },
          /* eslint-enable no-void */
        });


        // END OF IIFE
      }());
      /* - */

      /** **************************************************************************
       *
       * Extends overslash with object types.
       *
       * objects.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . isObject                    is a given variable an object?
       *  . isLiteralObject             is a given variable a literal object?
       *  . isFunction                  is a given variable a function?
       *  . isArray                     is a given value an array?
       *  . isMath                      is a given value a Math object?
       *  . isDate                      is a given value a Date?
       *  . isEmpty                     is a given array, string or object empty?
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -,
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Public Static Methods ------------------------------------------------

        extend(Overslash, {
          /**
           * Is a given variable an object?
           * (copied from: http://underscorejs.org)
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isObject(obj) {
            const type = typeof obj;
            return (type === 'function' || type === 'object') && !!obj;
          },

          /**
           * Is a given variable a literal object?
           *
           * @method (arg1)
           * @private
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.3
           */
          isLiteralObject(obj) {
            return Object.prototype.toString.call(obj) === '[object Object]';
          },

          /**
           * Is a given variable a function?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isFunction(obj) {
            return Object.prototype.toString.call(obj) === '[object Function]';
          },

          /**
           * Is a given value an array?
           * (Delegates to ECMA5's native Array.isArray.)
           * (copied from: http://underscorejs.org)
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          /* istanbul ignore next */
          isArray(obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
          },

          /**
           * Is a given value a Math object?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          /* istanbul ignore next */
          isMath(obj) {
            return Object.prototype.toString.call(obj) === '[object Math]';
          },

          /**
           * Is a given value a Date?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          isDate(obj) {
            return Object.prototype.toString.call(obj) === '[object Date]';
          },

          /**
           * Is a given array, string or object empty?
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to test,
           * @returns {Boolean}   returns true or false,
           * @since 0.0.0
           */
          /* eslint-disable no-restricted-syntax, no-prototype-builtins */
          isEmpty(obj) {
            let key;
            if (obj === null) return true;
            if (this.isArray(obj) || this.isString(obj)) return obj.length === 0;
            // Check that the object has no enumerable own-properties.
            // If ECMAScript 5 support only: 'return Object.keys(obj).length === 0;'
            // Otherwise, parse all properties.
            for (key in obj) if (obj.hasOwnProperty(key)) return false;
            return true;
          },
          /* eslint-enable no-restricted-syntax, no-prototype-builtins */
        });


        // END OF IIFE
      }());
      /* eslint-enable no-underscore-dangle */

      /** **************************************************************************
       *
       *  Extends overslash with operations on Objects (optional).
       *
       * objectsops.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . clone                       clones a literal object or an array,
       *  . extend                      extends a given object with all the properties,
       *  . keys                        retrieves all the names of the object's,
       *  . forPropIn                   parses all the names of the object's,
       *  . assign                      extends source with target(s),
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -,
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Public Static Methods ------------------------------------------------

        extend(Overslash, {
          /**
           * Clones a literal object or an array.
           *
           * @method (arg1)
           * @public
           * @param {Object}      the object to clone,
           * @returns {Object}    returns the cloned object,
           * @since 0.0.0
           */
          /* eslint-disable no-void, no-restricted-syntax */
          clone(obj) {
            const clone = this.isArray(obj) ? [] : {};
            let prop;

            if (!this.isObject(obj)) return void 0;

            for (prop in obj) {
              if (this.isArray(obj[prop])) {
                clone[prop] = this.clone(obj[prop]);
              } else if (this.isObject(obj[prop])) {
                clone[prop] = this.extend(obj[prop]);
              } else {
                clone[prop] = obj[prop];
              }
            }
            return clone;
          },
          /* eslint-enable no-void, no-restricted-syntax */

          /**
           * Extends a given object with all the properties in passed-in object(s).
           * (copied from: http://underscorejs.org and added recursivity)
           *
           * @method (arg1)
           * @public
           * @param {Object}      the objects to merge,
           * @returns {Object}    the resulting object,
           * @since 0.0.0
           */
          /* eslint-disable no-restricted-syntax, no-param-reassign, prefer-rest-params */
          extend(obj) {
            let source
              , prop
              ;

            if (!this.isObject(obj)) return obj;

            for (let i = 1; i < arguments.length; i++) {
              source = arguments[i];
              for (prop in source) {
                // if (!this.isArray(arguments[i][prop]) && this.isObject(arguments[i][prop])) {
                if (this.isLiteralObject(arguments[i][prop])) {
                  obj[prop] = obj[prop] !== undefined ? obj[prop] : {};
                  this.extend(obj[prop], arguments[i][prop]);
                } else if (hasOwnProperty.call(source, prop)) {
                  obj[prop] = this.isArray(source[prop])
                    ? this.clone(source[prop])
                    : source[prop];
                }
              }
            }
            return obj;
          },
          /* eslint-enable no-restricted-syntax, no-param-reassign, prefer-rest-params */

          /**
           * Retrieves all the names of the object's own enumerable properties.
           * (ECMAScript 5 only).
           *
           * @method (arg1)
           * @public
           * @param {Object}      the input object,
           * @returns {Array}     returns the names of the keys,
           * @since 0.0.0
           */
          keys(obj) {
            return Object.keys(obj);
          },

          /**
           * Parses all the names of the object's own enumerable properties.
           * (replace for...in statement).
           * (ECMAScript 5 only).
           *
           * @method (arg1, arg2)
           * @public
           * @param {Object}      the input object,
           * @returns {Array}     returns the names of the keys,
           * @since 0.0.0
           */
          forPropIn(obj, callback) {
            // var keys = overslash.keys(obj);
            this.keys(obj).forEach((key) => {
              /* istanbul ignore next */
              if ({}.hasOwnProperty.call(obj, key)) {
                callback(key);
              }
            });
          },

          /**
           * Extends source with target(s) while preserving the assessors.
           *
           * Nota:
           * Clones a literal object at the first level while preserving the
           * assessors (get and set). This should be the prefered method to Clones
           * a literal object or a prototype that includes get and set assessors.
           *
           * Example:
           * To clone a function prototype:
           * var a = _.assign({}, fn.prototype);  // clone the original prototype,
           * _.assign(fn2.prototype, a);          // assign it to fn2.prototype,
           *
           * @method (...arg1)
           * @public
           * @param {Object}      the objects to 'fusion',
           * @returns {Object}    returns the reassigned object,
           * @since 0.0.0
           */
          /* eslint-disable no-param-reassign, no-loop-func, prefer-rest-params */
          assign() {
            const target = arguments[0];
            let source
              , descriptors
              , i
              ;

            for (i = 1; i < arguments.length; i++) {
              source = arguments[i];
              descriptors = Object.keys(source).reduce((props, key) => {
                props[key] = Object.getOwnPropertyDescriptor(source, key);
                return props;
              }, {});
            }
            Object.defineProperties(target, descriptors);
            return target;
          },
          /* eslint-enable no-param-reassign, no-loop-func, prefer-rest-params */
        });


        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      /** **************************************************************************
       *
       * Extends overslash with operations on Arrays (optional).
       *
       * arrayops.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . contains                    returns true if the array contains the passed-in value,
       *  . flatten                     flattens a nested array,
       *  . max                         returns the maximum value in the array,
       *  . min                         returns the minimum value in the array,
       *  . share                       returns the list of the elements in common,
       *  . pull                        removes the matching items from the passed-in array,
       *  . include                     returns the list of items included in the passed-in array,
       *  . partition                   returns matching and non matching criteria,
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -,
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable one-var, semi-style, no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Public Static Methods ------------------------------------------------

        extend(Overslash, {

          /**
           * Returns true if the array contains the passed-in value.
           *
           * Note:
           * The array must be a first-level only array.
           *
           * @method(arg1, arg2)
           * @public
           * @param {Object}      the array,
           * @param {Number/string} the passed-in value,
           * @returns {Boolean}   returns true if the array contains the value,
           * @since 0.0.0
           */
          contains(list, value) {
            // jreturn list.indexOf(value) === -1 ? false : true;
            return list.indexOf(value) !== -1;
          },

          /**
           * Flattens a nested array (the nesting can be to any depth).
           *
           * @method (arg1, [arg2])
           * @public
           * @param {Array}       the input object,
           * @param {Boolean}     the flattened level, false deep, true only first level,
           * @returns {Array}     returns the flattened array or void(0),
           * @since 0.0.0
           */
          /* eslint-disable no-void, no-plusplus, prefer-spread */
          flatten(obj, shallow) {
            let o = []
              , idx = 0
              , i
              ;

            if (!this.isArray(obj)) return void 0;
            if (shallow) return [].concat.apply([], obj);

            for (i = 0; i < obj.length; i++) {
              if (this.isArray(obj[i])) {
                o = o.concat(this.flatten(obj[i]));
                idx = o.length;
              } else {
                o[idx++] = obj[i];
              }
            }
            return o;
          },
          /* eslint-enable no-void, no-plusplus, prefer-spread */

          /**
           * Returns the maximum value in the array.
           *
           * @method (arg1)
           * @public
           * @param {Array}       the input object,
           * @returns {Number}    returns the max value or void(0),
           * @since 0.0.0
           */
          /* eslint-disable no-void */
          max(obj) {
            let max = null
              , i
              ;

            if (!this.isArray(obj)) return void 0;

            const o = this.flatten(obj);
            for (i = 0; i < o.length; i++) {
              if (max === null || max < o[i]) {
                max = typeof o[i] === 'number' ? o[i] : max;
              }
            }
            return max !== null ? max : void 0;
          },
          /* eslint-enable no-void */

          /**
           * Returns the minimum value in the array.
           *
           * @method (arg1)
           * @public
           * @param {Array}       the input object,
           * @returns {Number}    returns the min value or void(0),
           * @since 0.0.0
           */
          /* eslint-disable no-void */
          min(obj) {
            let min = null
              , i
              ;

            if (!this.isArray(obj)) return void 0;

            const o = this.flatten(obj);
            for (i = 0; i < o.length; i++) {
              if (min === null || min > o[i]) {
                min = typeof o[i] === 'number' ? o[i] : min;
              }
            }
            return min !== null ? min : void 0;
          },
          /* eslint-enable no-void */

          /**
           * Returns the list of the elements the passed-in arrays have in common.
           *
           * @method (arg)
           * @public
           * @param {Array}       n arrays to compare,
           * @returns {Array}     returns the list of elements in common or empty,
           * @since 0.0.0
           */
          share(array) {
            const result = [];
            let item
              , i
              , j
              ;

            // for (i = 0; i < array.length; i++) {
            //   item = array[i];
            //   if (overslash.contains(result, item)) continue;
            //   for (j = 1; j < arguments.length; j++) {
            //     if (!overslash.contains(arguments[j], item)) break;
            //   }
            //   if (j === arguments.length) result.push(item);
            // }
            for (i = 0; i < array.length; i++) {
              item = array[i];
              if (!this.contains(result, item)) {
                for (j = 1; j < arguments.length; j++) {
                  /* eslint-disable-next-line prefer-rest-params */
                  if (!this.contains(arguments[j], item)) {
                    break;
                  }
                }
                if (j === arguments.length) {
                  result.push(item);
                }
              }
            }
            return result;
          },

          /**
           * Removes the matching items from the passed-in array.
           *
           * @method (arg1, ...args)
           * @public
           * @param {Array}       the passed-in array,
           * @param {...}         the items to remove (list of items or array),
           * @returns {Array}     returns an array with the items removed,
           * @since 0.0.0
           */
          pull(arr, ...args) {
            const values = Array.isArray(args[0]) ? args[0] : args;
            const removed = [];

            let index;
            values.forEach((val) => {
              index = arr.indexOf(val);
              if (index > -1) {
                removed.push(arr.splice(index, 1)[0]);
              }
            });
            return removed;
          },

          /**
           * Returns the list of items included in the passed-in array.
           *
           * @method (arg1, ...args)
           * @public
           * @param {Array}       the passed-in array,
           * @param {...}         the items to test (list of items or array),
           * @returns {Array}     returns an array with the matching items,
           * @since 0.0.0
           */
          include(arr, ...args) {
            const values = Array.isArray(args[0]) ? args[0] : args;
            return values.filter((val) => arr.indexOf(val) > -1);
          },

          /**
           * Returns matching and non matching criteria.
           *
           * The first item in the returned array is an array of items that match
           * the criteria, and the second is items that dont.
           *
           * @method (arg1, criteria)
           * @public
           * @param {Array}       the passed-in array,
           * @param {Function}    the matching criteria functions,
           * @returns {Array}     returns an array of matching and non matching items,
           * @since 0.0.0
           */
          partition(arr, criteria) {
            return [
              arr.filter((item) => criteria(item)),
              arr.filter((item) => !criteria(item)),
            ];
          },
        });


        // END OF IIFE
      }());
      /* eslint-enable one-var, semi-style, no-underscore-dangle */

      /** **************************************************************************
       *
       * Extends overslash with function types (optional).
       *
       * functions.js is just a literal object that contains a set of functions. It
       * can't be intantiated.
       *
       * Private Functions:
       *  . none,
       *
       *
       * Public Static Methods:
       *  . none
       *
       *
       *
       * @namespace    -
       * @dependencies none
       * @exports      -,
       * @author       -
       * @since        0.0.0
       * @version      -
       * ************************************************************************ */
      /* - */
      /* eslint-disable no-underscore-dangle */

      (function() {
        // START OF IIFE


        // -- Module Path


        // -- Local Modules


        // -- Local Constants


        // -- Local Variables


        // -- Public Static Methods ------------------------------------------------

        extend(Overslash, {
          //
        });


        // END OF IIFE
      }());
      /* eslint-enable no-underscore-dangle */

      // Returns the library name:
      return Overslash;
    }));
  }
  /* eslint-enable no-shadow */

  // Returns the library name:
  return $__TREE.src.spine;
}));

// -- Export
export default $__ES6GLOB.Spine;
